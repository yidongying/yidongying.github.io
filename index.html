<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />



  <meta name="google-site-verification" content="true" />








  <meta name="baidu-site-verification" content="true" />







  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹">
<meta name="keywords" content="小鱼 前端 程序媛 码农 工程师 It民工 苦逼码农">
<meta property="og:type" content="website">
<meta property="og:title" content="易冬英的博客">
<meta property="og:url" content="https://yidongying.github.io/index.html">
<meta property="og:site_name" content="易冬英的博客">
<meta property="og:description" content="记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="易冬英的博客">
<meta name="twitter:description" content="记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yidongying.github.io/"/>





  <title>易冬英的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">易冬英的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">小鱼儿与大前端</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2018/07/15/小鱼厨子养成记-一-7月/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/07/15/小鱼厨子养成记-一-7月/" itemprop="url">小鱼厨子养成记(一):7月</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-07-15T14:51:20+08:00">
                2018-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2018/07/15/小鱼厨子养成记-一-7月/" class="leancloud_visitors" data-flag-title="小鱼厨子养成记(一):7月">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前言</strong><br>作为一枚会撸码爱篮球会写作爱动漫的非二次元吃货程序媛,在前段时间的端午,回家吃了顿饭之后,感受到了来自老爸的厨艺鄙夷以及来自老妈的美味诱惑,于是决定开始我的厨艺生涯.<br>每周解锁一道新品种(哈哈,对于我来说,一切都是新品种)</p>
<p><strong>为啥写博客?</strong><br>写这个博客呢,只有两个目的:<br>1.记录一下自己的厨艺成长过程;(真相是,我这人比较懒,立个flag,鞭策一下自己)<br>2.记录每道菜的制作过程,随手拿来当菜谱用,哈哈!</p>
<p>先秀一波图,走你!</p>
<p><strong>来自老妈的厨艺:</strong><br><img src="https://img-blog.csdn.net/20180715180530942?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180715180645436?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>(原谅我手机的渣像素,实物比这好看)</p>
<p>啦啦啦啦,现在就开始我的厨艺表演了!</p>
<p><strong>2018年7月1日 周日</strong></p>
<p><strong>今日午餐菜单: 海带排骨汤、啤酒鸭、素炒鱼丝、甜豆炒瘦肉，外加绿豆汤</strong><br><strong>新品解锁：啤酒鸭</strong><br>材料准备：半片鸭、青椒、红椒、葱、姜、蒜、生抽、老抽、盐、八角、啤酒一瓶（只需要用半瓶，但没有半瓶卖，笑哭脸）<br>制作过程：<br>步骤一：<br>先把鸭子剁成块，焯水捞出；<br>葱姜蒜什么的切好，备用；<br>（至于切成什么形状，看个人爱好了， 我是把姜切片，辣椒切段了，葱忘记买了，然后辣椒籽弄掉）<br>步骤二：<br>炒锅里放油，油热了之后爆炒姜蒜辣椒，葱先不炒，因为熟得快，<br>然后把配料捞出，再倒点油，把鸭块倒入，中火炸一会，沥出鸭油，因为比较油腻，可以把油倒出一些；<br>步骤三：<br>放入盐、生抽、老抽，八角调味，倒入啤酒没过鸭块，半片鸭差不多半瓶的样子，<br>盖上锅盖，大火煮开，大约十分钟之后转小火慢炖，<br>把爆炒过的配料倒入，改大火翻炒，之后把葱放入，翻炒收干汁出锅！</p>
<p>大概就是这样了，上菜吧！</p>
<p><img src="https://img-blog.csdn.net/20180715192127345?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>等等，打开方式不对，我好像忘记单独拍啤酒鸭了，<br>不过这么明显的三个菜，啤酒鸭没有不认识的吧？（左边第一盘）</p>
<p>那中间那盘是啥？</p>
<p>这个是特地从家乡带的鱼丝，啥》？ 鱼丝你不认识？ 出门右转找百度（<a href="https://baike.baidu.com/item/鱼丝/7386802?fr=aladdin）" target="_blank" rel="noopener">https://baike.baidu.com/item/鱼丝/7386802?fr=aladdin）</a> 。<br>说下这个菜的做法吧<br>大致是这样的：<br>1.烧开水把鱼丝煮软，沥水捞出备用；<br>2.姜蒜辣椒爆炒，用姜是因为有鱼腥味（但鱼丝里没有鱼，就跟鱼香肉丝没有鱼是一样的道理，憨笑脸）<br>3.把鱼丝倒入，加入盐，调味粉等，入味之后出锅装盘，搞定，就是这么简单！</p>
<p>第三盘的甜豆炒肉就没有说的必要啦！</p>
<p>再秀一张完整的图：<br><img src="https://img-blog.csdn.net/201807151922487?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>总结：炎炎夏日，啤酒配上鸭，绿豆配上汤，排骨配海带，超级享受！</p>
<p><strong>2018年7月8日 周日</strong></p>
<p><strong>今日午餐菜单：海带海粉排骨汤、鸡蛋饼、辣椒炒肉</strong><br><strong>新品解锁：鸡蛋饼</strong><br>材料准备：鸡蛋3个，面粉、葱、盐、水、植物油、醋<br>操作步骤：<br>1.香葱切细，备用，<br>用一个稍大一些的碗，倒入一定量的面粉，然后把鸡蛋磕进去，缓缓倒入清水，加入食盐和葱花；</p>
<p>2.用汤匙搅拌均匀，打成可以流淌的面糊状；这一步很关键，不能有面粉结块的现象</p>
<p>3.在锅中倒入植物油，先不加热，用汤匙装一匙面糊淋入锅内，<br>迅速转动锅子，将粉浆水平摊在锅底成圆饼状，</p>
<p>4.将锅子移到火上，用小火加热至面糊凝固成型，再翻面用小火煎另一面，直到两面都变得有鞋焦黄上色，出锅！</p>
<p>好了，上菜！<br><img src="https://img-blog.csdn.net/20180715200220163?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180715211234426?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>额额，只能说还凑合吧，毕竟葱花最后用的青椒代替！（手动表情-捂脸笑）</p>
<p>这个汤，我单独说一下，<br>里面放了海粉（我也不确定叫法，从家里带的），这个海粉，下火的，夏天炖汤喝贼爽，滑溜溜的。<br>为了看清原料，我单独来一张图：<br><img src="https://img-blog.csdn.net/20180715200702782?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>诺，就是那个看起来有点点褐黄色的东西，老妈心疼我特别容易上火，走之前给我塞包里，也不知道这边有没有得买。</p>
<p>总结：说啥好呢？这周貌似有点清淡啊！</p>
<p><strong>2018年7月15日 周日</strong></p>
<p><strong>今日早餐菜单：优酸乳  三明治</strong><br><strong>今日午餐菜单：红烧鱼块  油炸茄子 凉拌萝卜 水果捞</strong><br>早餐的三明治呢，做法很简单<br>就是稍微煎一下切片面包，煎一个鸡蛋，煎两片火腿片，生菜忘记放了，夹好，搞定！<br>直接上图吧！<br><img src="https://img-blog.csdn.net/20180715202116719?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>冰过的牛奶，口感俱佳！</p>
<p><strong>今日新品一：红烧鱼块</strong><br>材料准备：鱼块、葱、姜、蒜、青椒、红椒、黄酒、盐、五香粉、淀粉，酱油<br>制作过程：<br>步骤一：<br>鱼块洗净切好，放入少许淀粉，五香粉和盐，拌均匀。<br>步骤二：<br>将姜蒜辣椒爆炒后装盘，备用；<br>步骤三：<br>倒入油，烧热油锅后将鱼块倒入，大火炸几分钟，炸至两边带点焦黄，倒入少许黄酒，酱油、调味粉进行调味，<br>倒入半碗水，盖上锅盖，大火焖几分钟；<br>步骤四：<br>将姜蒜辣椒、葱倒入，进行翻炒入味收汁，出锅！<br>注意：翻炒时不要将鱼块翻烂，最好是翻一遍就出锅。<br>上菜吧！<br><img src="https://img-blog.csdn.net/20180715205139341?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>略微有点翻烂了，，卖相不咋地，不过味道还可以啦！</p>
<p><strong>今日新品二：油炸茄子</strong><br>材料准备：茄子一条，面粉，淀粉、鸡蛋、盐、酱油<br>制作过程：<br>步骤一：<br>将茄子切条，放在冷水中泡大概十分钟左右；<br>步骤二：<br>将茄子捞出，加入少许盐和酱油搅拌，腌制片刻让茄子入味；<br>步骤三：<br>取一只大碗，将面粉倒入，再加入少许淀粉，打入一个鸡蛋，加一些水搅拌，调成面糊备用；<br>步骤四：<br>锅内倒入油，油锅至七八成热时（表面有小气泡翻滚），将腌好的茄子滚在面糊上，下锅内炸，翻面炸至两面焦黄夹出装盘即可！<br>小提示：<br>1.腌制师可以加入胡椒粉、辣椒粉等调味料，随你喜欢；<br>2.炸的时候不宜太大火，中火即可，记得翻面，免得烧焦；<br>3.调面糊为啥加鸡蛋？因为加鸡蛋可以更脆更香。</p>
<p>嗯，就酱，上菜吧！<br><img src="https://img-blog.csdn.net/20180715211023695?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>然后是午餐完整图来一张:<br><img src="https://img-blog.csdn.net/20180715211145309?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>最后再上几张图，都是日常操作，记不得哪一天的了， 哈哈！<br><img src="https://img-blog.csdn.net/20180715211336977?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180715211401106?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><img src="https://img-blog.csdn.net/20180715211308270?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2018/02/05/你真的了解箭头函数吗/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/你真的了解箭头函数吗/" itemprop="url">深入浅出ES6(一): 你真的了解箭头函数吗</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T20:09:15+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深入浅出ES6/" itemprop="url" rel="index">
                    <span itemprop="name">深入浅出ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/02/05/你真的了解箭头函数吗/" class="leancloud_visitors" data-flag-title="深入浅出ES6(一): 你真的了解箭头函数吗">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言<br>这个系列主要是说明ES6的新特性,从2015年到现在,es6出来也有挺长一段时间了,在项目中也在普遍使用这些特性.,网上的写es6的文章也大把, 但我感觉可能还是停留在会用的阶段,,至于为什么要这么用, 又为什么会出现这个特性,解决了什么样的问题,这些都有些一知半解. 所以,打算抽时间去了解es6未知的一面.<br>这篇文章,就先从用的最多的箭头函数开始-&gt;</p>
<p><strong>箭头函数的由来</strong><br><strong>为什么叫箭头函数?</strong><br>因为,它的定义用的是一个箭头.<br>那为什么要用一个箭头?<br>先来看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">    document.bgColor = &quot;brown&quot;;  // red</span><br><span class="line">  // --&gt;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有没觉得很奇怪?在注释里边的代码也有效?当然,如果知道注释风格的代码的人,应该可以理解.</p>
<p>箭头符号在JavaScript诞生时就已经存在，当初第一个JavaScript教程曾建议在HTML注释内包裹行内脚本，这样可以避免不支持JS的浏览器误将JS代码显示为文本。</p>
<p>老式浏览器会将这段代码解析为两个不支持的标签和一条注释，只有新式浏览器才能识别出其中的JS代码。</p>
<p>为了支持这种奇怪的hack方式，浏览器中的JavaScript引擎将<code>&lt;!--</code>这四个字符解析为单行注释的起始部分，我没开玩笑，这自始至终就是语言的一部分，直到现在仍然有效, 这种注释符号不仅出现<code>&lt;script&gt;</code>标签后的首行，在JS代码的每个角落你都有可能见到它，甚至在Node中也是如此。</p>
<p>碰巧，这种注释风格首次在ES6中被标准化了，但在新标准中箭头被用来做其它事情。</p>
<p>箭头序列–&gt;同样是单行注释的一部分。古怪的是，在HTML中–&gt;之前的字符是注释的一部分，而在JS中–&gt;之后的部分才是注释。</p>
<p>你一定感到陌生的是，只有当箭头在行首时才会注释当前行。这是因为在其它上下文中，–&gt;是一个JS运算符：<code>“趋向于”运算符！</code></p>
<blockquote>
<p>function countdown(n) {<br>      while (n –&gt; 0)  // “n goes to zero”<br>        alert(n);<br>      blastoff();<br>    }</p>
</blockquote>
<p>上面这段代码可以正常运行，循环会一直重复直到n趋于0，这当然不是ES6中的新特性，它只不过是将两个你早已熟悉的特性通过一些误导性的手段结合在一起。你能理解么？通常来说，类似这种谜团都可以在Stack Overflow上找到答案。</p>
<p>当然，同样地，小于等于操作符&lt;=也形似箭头，你可以在JS代码、隐藏的图片样式中找到更多类似的箭头，但是我们就不继续寻找了，你应该注意到我们漏掉了一种特殊的箭头。<br>当然，同样地，小于等于操作符&lt;=也形似箭头，你可以在JS代码、隐藏的图片样式中找到更多类似的箭头，但是我们就不继续寻找了，你应该注意到我们漏掉了一种特殊的箭头。</p>
<blockquote>
<p><code>&lt;!--</code>    单行注释<br><code>--&gt;</code>    “趋向于”操作符<br> <code>&lt;=</code>   小于等于<br><code>=&gt;</code>       这又是什么？<br><code>=&gt;</code>   到底是什么？我们今天就来一探究竟。</p>
</blockquote>
<p>首先，我们谈论一些有关函数的事情。<br><br><br><strong>函数表达式无处不在</strong><br>JavaScript中有一个有趣的特性，无论何时，当你需要一个函数时，你都可以在想添加的地方输入这个函数。</p>
<p><code>举个例子</code>，假设你尝试告诉浏览器用户点击一个特定按钮后的行为，你会这样写：</p>
<pre><code>$(&quot;#confetti-btn&quot;).click(
</code></pre><p>jQuery的.click()方法接受一个参数：一个函数。没问题，你可以在这里输入一个函数：</p>
<pre><code>$(&quot;#confetti-btn&quot;).click(function (event) {
  playTrumpet();
  fireConfettiCannon();
});
</code></pre><p>对 于现在的我们来说，写出这样的代码相当自然，而回忆起在这种编程方式流行之前，这种写法相对陌生一些，许多语言中都没有这种特性。1958年，Lisp首 先支持函数表达式，也支持调用lambda函数，而C++，Python、C#以及Java在随后的多年中一直不支持这样的特性。</p>
<p>现在截然不同，所有的四种语言都已支持<code>lambda</code>函数，更新出现的语言普遍都支持内建的lambda函数。我们必须要感谢JavaScript和早期的JavaScript程序员，他们勇敢地构建了重度依赖lambda函数的库，让这种特性被广泛接受。</p>
<p>令人伤感的是，随后在所有我提及的语言中，只有JavaScript的lambda的语法最终变得冗长乏味。</p>
<pre><code>// 六种语言中的简单函数示例
function (a) { return a &gt; 0; } // JS
[](int a) { return a &gt; 0; }  // C++
(lambda (a) (&gt; a 0))  ;; Lisp
lambda a: a &gt; 0  # Python
a =&gt; a &gt; 0  // C#
a -&gt; a &gt; 0  // Java
</code></pre><p><br><br><strong><em>箭袋中的新羽</em></strong><br>ES6中引入了一种编写函数的新语法</p>
<pre><code>// ES5
var selected = allJobs.filter(function (job) {
  return job.isSelected();
});
// ES6
var selected = allJobs.filter(job =&gt; job.isSelected());
</code></pre><p>当你只需要一个只有一个参数的简单函数时，可以使用新标准中的箭头函数，它的语法非常简单：标识符=&gt;表达式。你无需输入function和return，一些小括号、大括号以及分号也可以省略。</p>
<p>（我个人对于这个特性非常感激，不再需要输入function这几个字符对我而言至关重要，因为我总是不可避免地错误写成functoin，然后我就不得不回过头改正它。）</p>
<p>如果要写一个接受多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）的函数，你需要用小括号包裹参数list。</p>
<pre><code>// ES5
var total = values.reduce(function (a, b) {
  return a + b;
}, 0);
// ES6
var total = values.reduce((a, b) =&gt; a + b, 0);
</code></pre><p>我认为这看起来酷毙了。</p>
<p>正如你使用类似Underscore.js和Immutable.js这样的库提供的函数工具，箭头函数运行起来同样美不可言。事实上，Immutable的文档中的示例全都由ES6写成，其中的许多特性已经用上了箭头函数。</p>
<p>那么不是非常函数化的情况又如何呢？除表达式外，箭头函数还可以包含一个块语句。回想一下我们之前的示例：</p>
<pre><code>// ES5
$(&quot;#confetti-btn&quot;).click(function (event) {
  playTrumpet();
  fireConfettiCannon();
});
</code></pre><p>这是它们在ES6中看起来的样子：</p>
<pre><code>// ES6
$(&quot;#confetti-btn&quot;).click(event =&gt; {
  playTrumpet();
  fireConfettiCannon();
});
</code></pre><p>这是一个微小的改进，对于使用了Promises的代码来说箭头函数的效果可以变得更加戏剧性，}).then(function (result) { 这样的一行代码可以堆积起来。</p>
<p>注意，使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。</p>
<p>小提示：当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。</p>
<pre><code>// 为与你玩耍的每一个小狗创建一个新的空对象
var chewToys = puppies.map(puppy =&gt; {});   // 这样写会报Bug！
var chewToys = puppies.map(puppy =&gt; ({})); //
</code></pre><p>用小括号包裹空对象就可以了。</p>
<p>不幸的是，一个空对象{}和一个空的块{}看起来完全一样。ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始。因此，puppy =&gt; {}这段代码就被解析为没有任何行为并返回undefined的箭头函数。</p>
<p>更令人困惑的是，你的JavaScript引擎会将类似{key: value}的对象字面量解析为一个包含标记语句的块。幸运的是，{是唯一一个有歧义的字符，所以用小括号包裹对象字面量是唯一一个你需要牢记的小窍门。<br><br><br><br><br><strong>箭头函数与this</strong><br><br><br>既然要说箭头函数, 自然避不开this了<br>了解es5的人,应该知道, 在不同地方使用this,它的指向也有所不同, 但总归来讲, 实际上this总是指向最后调用它的对象.</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:10,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.a); //undefined</span><br><span class="line">            console.log(this); //window        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，fn函数始终没有执行，直到执行j();而j()又是通过window来调用，所以最后输出的this是window.<br>总的来说, this的调用方式和指向有以下几种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数调用方式和this指向:</span><br><span class="line">  （1）直接调用：函数内部this指向全局window</span><br><span class="line">  （2） 通过对象使用点来调用：函数内部this指向调用对象</span><br><span class="line">  （3） 触发事件调用函数：函数内部this指向调用触发事件的对象</span><br><span class="line">  （4） 以new的方式来调用：函数内部this指向本次函数执行时对应的一个匿名对象。</span><br><span class="line">  （5） 通过call的方法来间接调用方法：函数内部this指向call方法的第一个参数（自己指定this）。</span><br></pre></td></tr></table></figure>
<p>这篇文章的目的不是要解析this, 如果对this不清楚的童鞋,可以参考这篇文档: <a href="https://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank" rel="noopener">this 指向详细解析（箭头函数）</a>  </p>
<p>看到this在这么多调用方式下的指向都不同, 有没有被绕晕? 相信肯定也有很多童鞋跟我一样,踩过this的坑. 而箭头函数的存在, 就避免了这种指向问题,在箭头函数中, this总是指向词法作用域, 也就是外层的调用者.</p>
<p>看个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = function () &#123;</span><br><span class="line">            return new Date().getFullYear() - this.birth; // this指向window或undefined</span><br><span class="line">        &#125;;</span><br><span class="line">        return fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中,fn()并没有得到我们预期的日期, 而是出错,因为在fn()函数中,this.birth并不是指向当前obj,而是指向函数的调用者window, 因此birth是undefined,</p>
<p>现在让我们用箭头函数来改造这个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</span><br><span class="line">        return fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); // 27</span><br></pre></td></tr></table></figure>
<p>在箭头函数中, this指向的是外层调用者obj,因此最后拿到了birth这个参数.</p>
<p>另外,在箭头函数中,我们不再需要这种hack写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var that = this;</span><br></pre></td></tr></table></figure>
<p><strong>关于箭头函数的案例</strong><br>上面应该大致说明白了箭头函数吧?<br>那么现在,就来说说它的使用.<br><br><br><strong>改造开始</strong><br><br><br>首先，我们从一个例子开始，在 ES5 中，我们一般是这么书写的。</p>
<blockquote>
<p>var sum1 = function(num1, num2) { return num1 + num2; };</p>
</blockquote>
<p>那么，改造成箭头函数，它是什么样子呢？</p>
<blockquote>
<p>var sum2 = (num1, num2) =&gt; { return num1 + num2;};</p>
</blockquote>
<p>小括号内的参数列表和花括号内的代码被 =&gt; 分隔开了。这个就是箭头函数的魅力，箭头函数使得表达更加简洁，从而简化了我们的代码。</p>
<p>如果一个表达式的代码块, 只是 return 后面跟一个表达式，那么还可以进一步简化。</p>
<blockquote>
<p>var sum3 = (num1, num2) =&gt; num1 + num2;</p>
</blockquote>
<p>如果某个方法只含有一个参数。</p>
<blockquote>
<p>console.info(“=&gt; ES5 写法”);<br>var curf1 = function(v) {<br>return v;<br> };</p>
</blockquote>
<p>我们甚至可以省略小括号。</p>
<blockquote>
<p>console.info(“=&gt; ES6 写法”);<br>var curf2 = v =&gt; v;</p>
</blockquote>
<p>如果某个方法没有参数。</p>
<blockquote>
<p>console.info(“=&gt; ES5 写法”);<br>var f1 = function() {<br>return “梁桂钊”;<br>};</p>
</blockquote>
<p>我们仍可以提供一对空的小括号，如同不含参数的</p>
<blockquote>
<p>console.info(“=&gt; ES6 写法”);<br> var f2 = () =&gt; “梁桂钊”;</p>
</blockquote>
<p>补充一个例外，如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES5 写法&quot;);</span><br><span class="line">var f3 = function() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">real_name: &quot;梁桂钊&quot;,</span><br><span class="line">nick_name: &quot;LiangGzone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(f3());</span><br><span class="line"> </span><br><span class="line">console.info(&quot;=&gt; ES6 写法&quot;);</span><br><span class="line">var f4 = () =&gt; (&#123;real_name: &quot;梁桂钊&quot;,nick_name: &quot;LiangGzone&quot;&#125;);</span><br><span class="line">console.log(f4());</span><br></pre></td></tr></table></figure>
<p><br><br><strong>关于解构</strong><br>我们还可以使用到 ES6 解构赋值特性。ES5 写法，之前是这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f5 = function(person) &#123;</span><br><span class="line">return person.first + &apos; &apos; + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用到 ES6 解构赋值特性后，就更加好理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const f6 = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last;</span><br></pre></td></tr></table></figure>
<p><strong>关于回调函数</strong><br>我们经常使用回调函数，之前的常规的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES5 写法&quot;);</span><br><span class="line">var x1 = [1,2,3].map(function (x) &#123;</span><br><span class="line">return x * x;</span><br><span class="line">&#125;);</span><br><span class="line">console.info(x1);</span><br></pre></td></tr></table></figure>
<p>那么，现在我们可以进行改造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES6 写法&quot;);</span><br><span class="line">var x2 = [1,2,3].map(x =&gt; x * x);</span><br><span class="line">console.info(x2);</span><br></pre></td></tr></table></figure>
<p><strong>rest参数结合</strong></p>
<p>没有使用箭头函数，之前，我们的代码可能长这样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES5 写法&quot;);</span><br><span class="line">var x3 = function(...nums)&#123;</span><br><span class="line">return nums;</span><br><span class="line">&#125;</span><br><span class="line">console.info(x3(512, 1024));</span><br></pre></td></tr></table></figure>
<p>那么，现在我们可以进行改造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES6 写法&quot;);</span><br><span class="line">var x4 = (...nums) =&gt; nums;</span><br><span class="line">console.info(x4(512, 1024));</span><br></pre></td></tr></table></figure>
<p>那么, 我们什么时候会用到箭头函数呢?<br>ES6 的箭头函数在微软的新版本中有使用, 他们也在 Babel，Traceur，和 TypeScript 得到实现, 等等</p>
<p>以上就是我对箭头函数的一点点见解, 如果有不对的地方, 欢迎指正!</p>
<p>参考文档:<br>    (1) 深入浅出ES6（七）：箭头函数 Arrow Functions:<br>        <a href="https://blog.csdn.net/hqh642134542/article/details/78809951" target="_blank" rel="noopener">https://blog.csdn.net/hqh642134542/article/details/78809951</a><br>    (2).你看懂“箭头函数”了么？<br>        <a href="https://www.cnblogs.com/libin-1/p/5995457.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/5995457.html</a><br>    (3).this指向详细解析（箭头函数）:<br>        <a href="https://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank" rel="noopener">https://www.cnblogs.com/dongcanliang/p/7054176.html</a><br>    (4) 极客学院-箭头函数:<br>        <a href="https://wiki.jikexueyuan.com/project/es-six-deeply/arrow-functions.html" target="_blank" rel="noopener">https://wiki.jikexueyuan.com/project/es-six-deeply/arrow-functions.html</a><br>    (5) 廖雪峰-箭头函数:<br>        <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000</a><br>    (6) MDN-箭头函数:<br>        <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a><br>    (6) 阮一峰-箭头函数issue:<br>        <a href="https://github.com/ruanyf/es6tutorial/issues/150" target="_blank" rel="noopener">https://github.com/ruanyf/es6tutorial/issues/150</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/09/10/关于React-setState的实现原理（三-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/关于React-setState的实现原理（三-md/" itemprop="url">关于React setState的实现原理（三).md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T10:30:51+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react的概念理解/" itemprop="url" rel="index">
                    <span itemprop="name">react的概念理解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/10/关于React-setState的实现原理（三-md/" class="leancloud_visitors" data-flag-title="关于React setState的实现原理（三).md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://yidongying.github.io/2017/09/08/%E5%85%B3%E4%BA%8EReact-setState%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C-md/">上一篇文章中</a>提到事务即将结束时，会去调用FLUSH_BATCHED_UPDATES的flushBatchedUpdates方法执行批量更新，该方法会去遍历dirtyComponents，对每一项执行performUpdateIfNecessary方法，该方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">performUpdateIfNecessary: function (transaction) &#123;</span><br><span class="line">    if (this._pendingElement != null) &#123;</span><br><span class="line">      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);</span><br><span class="line">    &#125; else if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123;</span><br><span class="line">      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this._updateBatchNumber = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在我们的setState更新中，其实只会用到第二个  <strong>this._pendingStateQueue !== null</strong>  的判断，即如果<strong>_pendingStateQueue</strong>中还存在未处理的<strong>state</strong>，那就会执行<strong>updateComponent</strong>完成更新。<br>那<strong>_pendingStateQueue</strong>是何时被处理的呢，继续看！</p>
<p>通过翻阅<strong>updateComponent</strong>方法，我们可以知道<strong>_pendingStateQueue</strong>是在该方法中由<strong>_processPendingState(nextProps, nextContext)</strong>方法做了一些处理，该方法传入两个参数，新的props属性和新的上下文环境，这个上下文环境可以先不用管。我们看看<strong>_processPendingState</strong>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_processPendingState: function (props, context) &#123;</span><br><span class="line">    var inst = this._instance;    // _instance保存了Constructor的实例，即通过ReactClass创建的组件的实例</span><br><span class="line">    var queue = this._pendingStateQueue;</span><br><span class="line">    var replace = this._pendingReplaceState;</span><br><span class="line">    this._pendingReplaceState = false;</span><br><span class="line">    this._pendingStateQueue = null;</span><br><span class="line">    if (!queue) &#123;</span><br><span class="line">      return inst.state;</span><br><span class="line">    &#125;</span><br><span class="line">    if (replace &amp;&amp; queue.length === 1) &#123;</span><br><span class="line">      return queue[0];</span><br><span class="line">    &#125;</span><br><span class="line">    var nextState = _assign(&#123;&#125;, replace ? queue[0] : inst.state);</span><br><span class="line">    for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123;</span><br><span class="line">      var partial = queue[i];</span><br><span class="line">      _assign(nextState, typeof partial === &apos;function&apos; ? partial.call(inst, nextState, props, context) : partial);</span><br><span class="line">    &#125;</span><br><span class="line">    return nextState;</span><br><span class="line">  &#125;，</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么replace啊什么的都可以暂时不用看，主要先看for循环内部做的事情，replace我们暂时认为是false。<br>for循环遍历了<strong>_pendingStateQueue</strong>中所有保存的状态，对于每一个状态进行处理，处理时首先判断保存的是function还是object。若是function，就在inst的上下文中执行该匿名函数，该函数返回一个代表新state的object，然后执行assign将其与原有的state合并；若是object，则直接与state合并。<br><br><br>注意，传入setState的第一个参数如果是function类型，我们可以看到，其第一个参数nextState即表示更新之前的状态；第二个参数props代表更新之后的props，第三个context代表新的上下文环境。之后返回合并后的state。<br><br><br>这里还需要注意一点，这一点很关键，代码中出现了<strong>this._pendingStateQueue = null</strong>这么一段，这也就意味着<strong>dirtyComponents</strong>进入下一次循环时，执行<strong>performUpdateIfNecessary</strong>不会再去更新组件，这就实现了批量更新，即只做一次更新操作，React在更新组件时就是用这种方式做了优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，回来看我们的案例，当我们传入函数作为setState的第一个参数时，我们用该函数提供给我们的state参数来访问组件的state。该state在代码中就对应nextState这个值，这个值在每一次for循环执行时都会对其进行合并，因此第二次执行setState，我们在函数中访问的state就是第一次执行setState后已经合并过的值，所以会打印出2。然而直接通过this.state.count来访问，因为在执行对_pendingStateQueue的for循环时，组件的update还未执行完，this.state还未被赋予新的值，其实了解一下updateComponent会发现，this.state的更新会在_processPendingState执行完执行。所以两次setState取到的都是this.state.count最初的值0，这就解释了之前的现象。其实，这也是React为了解决这种前后state依赖但是state又没及时更新的一种方案，因此在使用时大家要根据实际情况来判断该用哪种方式传参。</p>
<p>接下来我们再来看看setState的第二个参数，回调函数，它是在什么时候执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        let me = this;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            me.setState(&#123;count: me.state.count + 1&#125;, function() &#123;</span><br><span class="line">                console.log(&apos;did callback&apos;);</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(&apos;hello&apos;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">        console.log(&apos;did update&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例控制台打印顺序是怎样的呢？<br>不卖关子了，答案是did update，did callback，hello。这里是在一个setTimeout中执行了setState，因此其处于一个单独的事务之中，所以hello最后打印容易理解。然后我们来看看setState执行更新时做了些啥。前面我们知道在执行完组件装载即调用了componentDidMount之后，事务开始执行一系列close方法，这其中包括调用FLUSH_BATCHED_UPDATES中的flushBatchedUpdates，我们来看看这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var flushBatchedUpdates = function () &#123;</span><br><span class="line">  // ReactUpdatesFlushTransaction&apos;s wrappers will clear the dirtyComponents</span><br><span class="line">  // array and perform any updates enqueued by mount-ready handlers (i.e.,</span><br><span class="line">  // componentDidUpdate) but we need to check here too in order to catch</span><br><span class="line">  // updates enqueued by setState callbacks and asap calls.</span><br><span class="line">  while (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    if (dirtyComponents.length) &#123;</span><br><span class="line">      var transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, null, transaction);    // 处理批量更新</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued = false;</span><br><span class="line">      var queue = asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue = CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();    // 处理callback</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看我做了中文标注的两个地方，这个方法其实主要就是处理了组件的更新和callback的调用。组件的更新发生在runBatchedUpdates这个方法中，下面的queue.notifyAll内部其实就是从队列中去除callback调用，因此应该是先执行完更新，调用componentDidUpdate方法之后，再去执行callback，就有了我们上面的结果。<br><br><br><strong>总结</strong><br>React在组件更新方面做了很多优化，这其中就包括了上述的批量更新。在componentDidMount中执行了N个setState，如果执行N次更新是件很傻的事情。React利用其独特的事务实现，做了这些优化。正是因为这些优化，才造成了上面见到的怪现象。还有一点，再使用this.state时一定要注意组件的生命周期，很多时候在获取state的时候，组件更新还未完成，this.state还未改变，这是很容易造成bug的一个地方，要避免这个问题，需要对组件生命周期有一定的了解。</p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/09/08/关于React-setState的实现原理（二-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/关于React-setState的实现原理（二-md/" itemprop="url">关于React setState的实现原理（二).md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T09:57:48+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react的概念理解/" itemprop="url" rel="index">
                    <span itemprop="name">react的概念理解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/08/关于React-setState的实现原理（二-md/" class="leancloud_visitors" data-flag-title="关于React setState的实现原理（二).md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章中,写到了关于Batch Update的实现,有不懂的童鞋可以回头看看 <a href="https://yidongying.github.io/2017/09/05/%E5%85%B3%E4%BA%8EReact-setState%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80-md/">上一篇文章</a><br><strong>React中的Transaction</strong><br>大家学过sql server的都知道我们可以批量处理sql语句，原理其实都是基于上一篇我们说的Datch Update机制。当所有的操作均执行成功，才会执行修改操作；若有一个操作失败，则执行rollback（回滚）。</p>
<p>在React中，我们介绍过事件会在函数前后执行自己的逻辑，具体就是调用perform方法进入一个事件，这个方法会传入一个method参数。执行perform时先执行initializeAll方法按照一定顺序执行一系列的initialize操作，然后执行传入的method，method执行完后，就执行closeAll方法按照一定顺序执行一系列的close操作。注意一种事件不能同时开启，否则会抛出异常。给一个例子是实现事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Transaction = require(&apos;./Transaction&apos;);</span><br><span class="line"></span><br><span class="line">// 我们自己定义的 Transaction</span><br><span class="line">var MyTransaction = function() &#123;</span><br><span class="line">  // do sth.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</span><br><span class="line">  getTransactionWrappers: function() &#123;</span><br><span class="line">    return [&#123;</span><br><span class="line">      initialize: function() &#123;</span><br><span class="line">        console.log(&apos;before method perform&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      close: function() &#123;</span><br><span class="line">        console.log(&apos;after method perform&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var transaction = new MyTransaction();</span><br><span class="line">var testMethod = function() &#123;</span><br><span class="line">  console.log(&apos;test&apos;);</span><br><span class="line">&#125;</span><br><span class="line">transaction.perform(testMethod);</span><br><span class="line"></span><br><span class="line">// before method perform</span><br><span class="line">// test</span><br><span class="line">// after method perform</span><br></pre></td></tr></table></figure>
<p>具体到实现上，React 中的 Transaction 提供了一个 Mixin 方便其它模块实现自己需要的事务。而要使用 Transaction 的模块，除了需要把 Transaction 的 Mixin 混入自己的事务实现中外，还需要额外实现一个抽象的 getTransactionWrappers 接口。这个接口是 Transaction 用来获取所有需要封装的前置方法（initialize）和收尾方法（close）的，因此它需要返回一个数组的对象，每个对象分别有 key 为 initialize 和 close 的方法。</p>
<p>当然在实际代码中 React 还做了异常处理等工作，这里不详细展开。有兴趣的同学可以参考源码中 Transaction 实现。</p>
<p>组件调用ReactDOM.render()之后，会执行一个_renderNewRootComponent的方法，大概是该方法执行了一个ReactUpdates.batchedUpdates()。 那么batchedUpdates是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var transaction = new ReactDefaultBatchingStrategyTransaction();</span><br><span class="line"></span><br><span class="line">var ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: false,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Call the provided function in a context within which calls to `setState`</span><br><span class="line">   * and friends are batched such that components aren&apos;t updated unnecessarily.</span><br><span class="line">   */</span><br><span class="line">  batchedUpdates: function (callback, a, b, c, d, e) &#123;</span><br><span class="line">    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = true;</span><br><span class="line"></span><br><span class="line">    // The code is written this way to avoid extra allocations</span><br><span class="line">    if (alreadyBatchingUpdates) &#123;</span><br><span class="line">      return callback(a, b, c, d, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return transaction.perform(callback, null, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，这个batchedUpdate是第一次调用alreadyBatchingUpdates是false（储存起来了），回去执行transaction.perform(method)（前边说过perform执行会进入一个时间），这样就进入第一个事务，</p>
<p>这个事务是啥我们现在不用管，我们只需要知道这个transaction是ReactDefaultBatchingStrategyTransaction的实例，它代表了其中一类事务的执行。然后会执行method方法，就会进行组件的首次装载。完成后会调用</p>
<p>componentDidMount(注意，此时还是在执行method方法，事务还没结束，事务只有在执行完method后执行一系列close才会结束),在该方法中，我们调用了setState，出现了一系列奇怪的现象。因此，我们再来看看</p>
<p>setState方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState = function (partialState, callback) &#123;</span><br><span class="line">  !(typeof partialState === &apos;object&apos; || typeof partialState === &apos;function&apos; || partialState == null) ? &quot;development&quot; !== &apos;production&apos; ? invariant(false, &apos;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&apos;) : _prodInvariant(&apos;85&apos;) : void 0;</span><br><span class="line">  this.updater.enqueueSetState(this, partialState);</span><br><span class="line">  if (callback) &#123;</span><br><span class="line">    this.updater.enqueueCallback(this, callback, &apos;setState&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>setState在调用时做了两件事，第一，调用enqueueSetState。该方法将我们传入的partialState添加到一个叫做_pendingStateQueue的队列中去存起来，然后执行一个enqueueUpdate方法。<br><br><br>第二，如果存在callback就调用enqueueCallback将其存入一个_pendingCallbacks队列中存起来。然后我们来看enqueueUpdate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class="line">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class="line">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class="line">  // function, like setState, forceUpdate, etc.; creation and</span><br><span class="line">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class="line"></span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  if (component._updateBatchNumber == null) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>上面的代码中，这个<strong>batchingStrategy</strong>就是上面的<strong>ReactDefaultBatchingStrategy</strong>，只是它通过<strong>inject</strong>的形式对其进行赋值，比较隐蔽。因此，我们当前的setState已经处于了这一类事务之中，isBatchingUpdates已经被置为true，所以将会把它添加到<strong>dirtyComponents</strong>中，在某一时刻做批量更新。<br><br><br>因此在前两个setState中，并没有做任何状态更新，以及组件更新的事，而仅仅是将新的state和该组件存在了队列之中，因此两次都会打印出0，我们之前的第一个问题就解决了，还有一个问题，我们接着往下走。<br><br><br>在setTimeout中执行的setState打印出了2和3，有了前面的铺垫，我们大概就能得出结论，这应该就是因为这两次setState分别执行了一次完整的事务，导致state被直接更新而造成的结果。那么问题来了，为什么setTimeout中的setState会分别执行两次不同的事务？之前执行ReactDOM.render开启的事务在什么时候结束了？我们来看下列代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: function () &#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line"></span><br><span class="line">function ReactDefaultBatchingStrategyTransaction() &#123;</span><br><span class="line">  this.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: function () &#123;</span><br><span class="line">    return TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码也是写在<strong>ReactDefaultBatchingStrategy</strong>这个对象中的。我们之前提到这个事务中<strong>transaction</strong>是<strong>ReactDefaultBatchingStrategyTransaction</strong>的实例，这段代码其实就是给该事务添加了两个在事务结束时会被调用的close方法。即在perform中的method执行完毕后，会按照这里数组的顺序<strong>[FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]</strong>依次调用其close方法。<br><br><br><strong>FLUSH_BATCHED_UPDATES</strong>是执行批量更新操作。<strong>RESET_BATCHED_UPDATES</strong>我们可以看到将<strong>isBatchingUpdates</strong>变回false，即意味着事务结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class="line">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class="line">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class="line">  // function, like setState, forceUpdate, etc.; creation and</span><br><span class="line">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123; //上一个事件结束执行过isBatchedUpdates=false,所以进入if中</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  if (component._updateBatchNumber == null) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>接下来再调用setState时（在setTimeout中，前文说过一步操作不会在主线程，我理解是在主线程结束才会执行，此时的主线程事件已经结束），enqueueUpdate不会再将其添加到dirtyComponents中，而是执行batchingStrategy.batchedUpdates(enqueueUpdate, component)开启一个新事务。<br><br><br>但是需要注意，这里传入的参数是enqueueUpdate，即perform中执行的method为enqueueUpdate，而再次调用该enqueueUpdate方法会去执行dirtyComponents那一步。这就可以理解为，处于单独事务的setState也是通过将组件添加到dirtyComponents来完成更新的，只不过这里是在enqueueUpdate执行完毕后立即执行相应的close方法完成更新，而前面两个setState需在整个组件装载完成之后，即在componentDidMount执行完毕后才会去调用close完成更新。总结一下4个setState执行的过程就是：先执行两次console.log，然后执行批量更新，再执行setState直接更新，执行console.log，最后再执行setState直接更新，再执行console.log，所以就会得出0,0,2,3。<br><br><br>到现在上面的问题已经解决，但是又出现一个新问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let me = this;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;   //页面中将打印出1</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let me = this;</span><br><span class="line">    me.setState(function(state, props) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(function(state, props) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;   //页面中将打印出2</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>这两种写法，一个是在setState中传入了object，一个是传入了function，却得到了两种不同的结果，这是什么原因造成的，这就需要我们去深入了解一下进行批量更行时都做了些什么。<br>关于这个部分, 可以看看我的<a href="https://yidongying.github.io/2018/07/05/%E5%85%B3%E4%BA%8EReact-setState%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89-md/">下一篇文章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/09/05/关于React-setState的实现原理（一-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/05/关于React-setState的实现原理（一-md/" itemprop="url">关于React setState的实现原理（一).md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-05T09:57:48+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react的概念理解/" itemprop="url" rel="index">
                    <span itemprop="name">react的概念理解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/05/关于React-setState的实现原理（一-md/" class="leancloud_visitors" data-flag-title="关于React setState的实现原理（一).md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在学习react的时候就对setSate的实现有比较浓厚的兴趣，那么对于下边的代码，可以快速回答吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let me = this;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(me.state.count);    // 打印</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(me.state.count);    // 打印</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">     me.setState(&#123;</span><br><span class="line">       count: me.state.count + 1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(me.state.count);   // 打印</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">     me.setState(&#123;</span><br><span class="line">       count: me.state.count + 1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(me.state.count);   // 打印</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码大家可能在很多地方看见过，结果是让你匪夷所思的0，0，2，3。 大部分人相信都不知道其中的原因，首先肯定会问：</p>
<p>为什么前两次为零，而加上setTimeout就可以打印出来？<br>为什么setTimeout打印出不同的结果？<br>那么请你接下来向下看，我首先说一下Batch Updata（批量更新）。如下图：<br><img src="https://img-blog.csdn.net/2018070510045176?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>什么是Batch Update ?</strong><br>在一些MV*框架中，就是将一段时间内对model的修改批量更新到view的机制。比如那前端比较火的React、vue为例。</p>
<p>在React中，我们在componentDidMount生命周期连续调用SetState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  this.setState(&#123; foo: 1 &#125;)</span><br><span class="line">  this.setState(&#123; foo: 2 &#125;)</span><br><span class="line">  this.setState(&#123; foo: 3 &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有Batch Update的情况下，上面的操作会导致三次组件渲染，但是使用Batch Update机制下时间上只运行了一次渲染。componentDidMount中三次对model的操作被优化为一次view更新，</p>
<p>不必要的Vitual Dom计算被忽略，从而提高了框架的效率。</p>
<p><strong>Batch Update的实现</strong><br>我们想到的可能就是数据结构中的栈和队列，比较一下还是使用一个queue来保存update，并在合适的时机对这个queue进行flush操作。那么现在有两个问题：</p>
<p><strong>什么时候创建这个queue</strong><br><strong>什么时候对这个queue进行flush</strong><br>那么我们要对Reac和Vue的源码进行分析，首先React：React中的Batch Update是通过Transaction（事务）来实现的。在React源码关于Transaction的部分可以用一幅画解释：</p>
<p><img src="https://img-blog.csdn.net/20180705100619182?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p> Transaction对一个函数进行包装，让React有机会在一个函数执行前和执行后运行特定的逻辑，从而完成对整个Batch Update流程的控制。</p>
<p>简单的说就是在要执行的函数中用事务包裹起来，在函数执行前加入initialize阶段，函数执行，最后执行close阶段。那么Batch Update中</p>
<p>在事件initialize阶段，一个update queue被创建。在事件中调用setState方法时，状态不会被立即调用，而是被push进Update queue中。</p>
<p>函数执行结束调用事件的close阶段，Update queue会被flush，这事新的状态才会被应用到组件上并开始后续的Virtual DOM更新，biff算法来对</p>
<p>model更新。</p>
<p>对比于React，Vue实现Batch update就简单多了：直接借助JS中的Event Loop。（参考阮老师的<a href="https://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">https://www.ruanyifeng.com/blog/2013/10/event_loop.html</a>）</p>
<p>Vue中的核心代码就仅仅20多行，如下:</p>
<p>// <a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js#L122-L148" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js#L122-L148</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Push a watcher into the watcher queue.</span><br><span class="line"> * Jobs with duplicate IDs will be skipped unless it&apos;s</span><br><span class="line"> * pushed when the queue is being flushed.</span><br><span class="line"> */</span><br><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">  const id = watcher.id</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当model被修改时，对应的watcher会被推入Update queue， 与此同时还会在异步队列中添加一个task用于flush当前的Update queue。</p>
<p>这样一来，当前的task中的其他watcher会被推进同一个Update queue中。当前task执行结束后，异步队列下一个task执行，update queue</p>
<p>会被 flush，并进行后续的更新操作。</p>
<p>为了让 flush 动作能在当前 Task 结束后尽可能早的开始，Vue 会优先尝试将任务 micro-task 队列，具体来说，在浏览器环境中 Vue 会优</p>
<p>先尝试使用 MutationObserver API 或 Promise，如果两者都不可用，则 fallback 到 setTimeout。</p>
<p>对比两个框架可以发现 React 基于 Transition 实现的 Batch Query 是一个不依赖语言特性的通用模式，因此有更稳定可控的表现，但缺点</p>
<p>是无法完全覆盖所有情况，例如对于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  setTimeout(_ =&gt; &#123;</span><br><span class="line">    this.setState(&#123; foo: 1 &#125;)</span><br><span class="line">    this.setState(&#123; foo: 2 &#125;)</span><br><span class="line">    this.setState(&#123; foo: 3 &#125;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 setTimeout 的回调函数「不受 React 控制」，其中的 setState 就无法得到优化，最终会导致 render 函数执行三次。</p>
<p>而 Vue 的实现则对语言特性乃至运行环境有很强的依赖，但可以更好的覆盖各种情况：只要是在同一个 task 中的修改都可以进行 Batch Update 优化。</p>
<p><br><br><br><br><strong>总结一下：</strong><br><br><br> React 在这里的更新和事务机制使用比较通用的处理方式。<br><br><br>比如默认第一次应用初始化的时候是一次事务的进行，在用户交互的时候是一次新的事务开始，会在同一次同步事务中标记 batchUpdate=true，这样的做法是不破坏使用者的代码。<br>然后如果是 Ajax，setTimeout 等要离开主线程进行异步操作的时候会脱离当前 UI 的事务，这时候再进入此次处理的时候 batchUpdate=false，所以才会 setState 几次就 render 几次。<br><br><br>Vue 的策略虽然在机制上雷同，但是从根本上来讲是一种延迟的批量更新机制。<br><br><br>Angular 在这里也处理得很巧妙，利用 zone.js 对 task 进行拦截，对 JS 现有场景进行 AOP，这样就成功的桥接了代码。<br><br><br>React 的事务是纯粹的 IO 模型的适配。<br><br><br> 那么Batch Update介绍到这里 ，在下一篇我们将参考React源码来分析setState的实现过程。<br> <br><br> <strong>参考文档:</strong><br>     饿了么前端团队对于batch Update的理解: <a href="https://zhuanlan.zhihu.com/p/28532725" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28532725</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/08/26/react-组件之间的传值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/26/react-组件之间的传值/" itemprop="url">react 组件之间的传值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-26T14:57:59+08:00">
                2017-08-26
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/26/react-组件之间的传值/" class="leancloud_visitors" data-flag-title="react 组件之间的传值">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>组件之间的传值,包括父子组件传值, 兄弟组件之间的传值,其中父子组件包括父组件向子组件传值和子组件向父组件传值,现在一一来介绍一下.</p>
<p>一.父组件向子组件传值<br>    父组件通过state向子组件传值, </p>
<p>// 父组件</p>
<p>constructor(props){</p>
<pre><code>super(props);

this.state = { name : &apos;yuxi&apos; }}
</code></pre><p>render(){ return 我是子组件 }</p>
<p>// 子组件</p>
<p>constructor(props){</p>
<p>super(props)</p>
<p>}</p>
<p>render(){</p>
<p>return <div>{this.props.name}<div></div></div></p>
<p>}</p>
<p>二.子组件向父组件传值<br>    有三种方式实现子组件向父组件传值. </p>
<p>（一）父组件通过state传值给子组件，子组件通过props获取父组件的传递值</p>
<pre><code>//(一)传值，即在父组件中声明好自己的state，然后传值，如下//1.初始值constructor() {

super();

this.state = {

  stateValue：true    }
</code></pre><p>  }//2.如有改变设定值this.setState({</p>
<pre><code>stateValue: false})//3.在父组件中传值

const huoquValue = this.props.stateValue;

if ( !this.props.stateValue ) {

    console.log(&apos;stateValue&apos;, this,.props.stateValue)

}
</code></pre><p>}</p>
<p>值得注意一点的是，setState 是一个异步方法，需要render值行的时候才会触发。可以参考博客【 React的setState立即执行方案】。</p>
<p>（二）父组件将方法传给子组件，子组件通过props来获取。</p>
<p>//父组件文件中：</p>
<pre><code>classTestHtmlextendsReact.Component{

//1.方法的声明

propsFunction() {

    console.log(&apos;声明在父组件的方法&apos;)

}

render() {

    return (

        //2.传递           

    )

}
</code></pre><p>}functionmapStateToProps(state, ownProps){    return {</p>
<pre><code>}
</code></pre><p>}functionmapDispatchToProps(dispatch){    return {</p>
<pre><code>    ...bindActionCreators(action, dispatch)

}
</code></pre><p>}</p>
<p>export default connect(mapStateToProps, mapDispatchToProps)(TestHtml)</p>
<p>//子组件中获取</p>
<button onclick="{this.props.propsFunction}">

<p>说明：写这一段的时候，突发奇想，竟然就把react-redux的页面结构的写出来了。好吧，等下写完这篇，如果有必要就具体写一下这个页面的结构类型吧。</p>
<p>（三）在父组件中调用子组件中的方法，通过ref和refs实现。</p>
<p>//这里就简要说明一下</p>
<p>//思路是给子组件一个ref，然后父组件通过refs获取</p>
<p>componentWillReceiveProps(nextProps) {</p>
<pre><code>this.refs.jiedian.子组件的方法名（）

//举个例子

// this.refs.getSwordButton.setFieldsValue({

//  xmlUrl: nextProps.sysCode==null ? nextProps.accountInfo.xmlUrl : nextProps.sysCode    // })
</code></pre><p>}</p>
<p>（四）特殊情况 </p>
<p>当你发现这些方法都不起作用的时候，或者说，因为某些限制而不能用的时候，你就换一下思路了。 </p>
<p>其实我们还可以通过action–reduce的方式在他们的外部且是公共的action-reduce中搞定。 </p>
<p>其中涉及到方法我们就直接新建一个方法，在action中声明，在reduce中实现。如果只是某个值，用不到函数的，我们可以直接在reduce里面设定，且赋值，最后通过mapStateToProps获取。 </p>
<p>关于mapStateToProps，可以直接参考【React依赖注入说明（mapStateToProps/mapDispatchToProps）】</p>
<p>总结 </p>
<p>1.父组件通过state向子组件传值，子组件通过props获取父组件所传的值。 </p>
<p>2.子组件通过prop获取父组件中定义的函数方法，但是需要在父组件调用子组件的标签中写明。 </p>
<p>3.父组件通过refs调用子组件中声明的方法，但是需要给子组件添加一个ref节点 </p>
<p>4.组件之间的交流也不一定要沉在这些直接性的关联的东西，我们的思维还可以提神一个高度，可以在action-reduce中搞定。 </p>
<p>三. 兄弟组件之间传值</p>
<p>兄弟组件的意思就是指没有任何嵌套关系的组件之间传值. 这种需求也是非常常见的,</p>
<p>如果组件之间没有任何关系，组件嵌套层次比较深（个人认为 2 层以上已经算深了），或者你为了一些组件能够订阅、写入一些信号，不想让组件之间插入一个组件，让两个组件处于独立的关系。对于事件系统，这里有 2 个基本操作步骤：订阅（subscribe）/监听（listen）一个事件通知，并发送（send）/触发（trigger）/发布（publish）/发送（dispatch）一个事件通知那些想要的组件。</p>
<p>下面讲介绍 3 种模式来处理事件，你能点击这里来比较一下它们。</p>
<p>简单总结一下：</p>
<p>(1) Event Emitter/Target/Dispatcher</p>
<p>特点：需要一个指定的订阅源</p>
<p>// to subscribe</p>
<p>otherObject.addEventListener(‘click’,function(){ alert(‘click!’); });</p>
<p>// to dispatch</p>
<p>this.dispatchEvent(‘click’);</p>
<p>(2) Publish / Subscribe</p>
<p>特点：触发事件的时候，你不需要指定一个特定的源，因为它是使用一个全局对象来处理事件（其实就是一个全局</p>
<p>广播的方式来处理事件）</p>
<p>// to subscribe</p>
<p>globalBroadcaster.subscribe(‘click’,function(){ alert(‘click!’); });</p>
<p>// to dispatch</p>
<p>globalBroadcaster.publish(‘click’);</p>
<p>(3) Signals</p>
<p>特点：与Event Emitter/Target/Dispatcher相似，但是你不要使用随机的字符串作为事件触发的引用。触发事件的每一个对象都需要一个确切的名字（就是类似硬编码类的去写事件名字），并且在触发的时候，也必须要指定确切的事件。（看例子吧，很好理解）</p>
<p>// to subscribe</p>
<p>otherObject.clicked.add(function(){ alert(‘click’); });</p>
<p>// to dispatch</p>
<p>this.clicked.dispatch();</p>
<p>如果你只想简单的使用一下，并不需要其他操作，可以用简单的方式来实现：</p>
<p>// 简单实现了一下 subscribe 和 dispatch</p>
<p>varEventEmitter = {</p>
<pre><code>_events: {},
</code></pre><p>dispatch: function (event,data) {</p>
<p>if(!this._events[event]) {// 没有监听事件</p>
<p>return;</p>
<pre><code>}
</code></pre><p>for(vari =0; i</p>
<p>this._events[event]<a href="data">i</a>;</p>
<pre><code>    }

},

subscribe: function (event, callback) {
</code></pre><p>// 创建一个新事件数组</p>
<p>if(!this._events[event]) {</p>
<p>this._events[event] = [];</p>
<pre><code>}
</code></pre><p>this._events[event].push(callback);</p>
<pre><code>}
</code></pre><p>};</p>
<p>otherObject.subscribe(‘namechanged’, function(data) { alert(data.name); });</p>
<p>this.dispatch(‘namechanged’, { name:’John’});</p>
<p>如果你想使用 Publish/Subscribe 模型，可以使用：PubSubJS</p>
<p>React 团队使用的是：js-signals它基于 Signals 模式，用起来相当不错。</p>
<p>Events in React</p>
<p>使用 React 事件的时候，必须关注下面两个方法：</p>
<p>componentDidMount</p>
<p>componentWillUnmount</p>
<p>在处理事件的时候，需要注意：</p>
<p>在 componentDidMount 事件中，如果组件挂载（mounted）完成，再订阅事件；当组件卸载（unmounted）的时候，在 componentWillUnmount 事件中取消事件的订阅。</p>
<p>（如果不是很清楚可以查阅 React 对生命周期介绍的文档，里面也有描述。原文中介绍的是 componentWillMount 个人认为应该是挂载完成后订阅事件，比如Animation这个就必须挂载，并且不能动态的添加，谨慎点更好）</p>
<p>因为组件的渲染和销毁是由 React 来控制的，我们不知道怎么引用他们，所以EventEmitter 模式在处理组件的时候用处不大。</p>
<p>pub/sub 模式可以使用，你不需要知道引用。</p>
<p>下面来一个例子：实现有多个 product 组件，点击他们的时候，展示 product 的名字。</p>
<p>(我在例子中引入了之前推荐的 PubSubJS 库，如果你觉得引入代价太大，也可以手写一个简版，还是比较容易的，很好用哈，大家也可以体验，但是我还是不推荐全局广播的方式)</p>
<p>// 定义一个容器</p>
<p>varProductList = React.createClass({</p>
<p>render:function(){</p>
<p>return(</p>
<pre><code>&lt;div&gt;

        &lt;ProductSelection /&gt;

        &lt;Product name=&quot;product 1&quot; /&gt;

        &lt;Product name=&quot;product 2&quot;/&gt;

        &lt;Product name=&quot;product 3&quot; /&gt;

&lt;/div&gt;

  );

}
</code></pre><p>});</p>
<p>// 用于展示点击的产品信息容器</p>
<p>varProductSelection = React.createClass({</p>
<p>getInitialState:function(){</p>
<p>return{</p>
<p>selection:’none’</p>
<pre><code>};
</code></pre><p>  },</p>
<p>componentDidMount:function(){</p>
<p>this.pubsub_token = PubSub.subscribe(‘products’,function(topic, product){</p>
<pre><code>  this.setState({

    selection: product

  });

}.bind(this));
</code></pre><p>  },</p>
<p>componentWillUnmount:function(){</p>
<pre><code>PubSub.unsubscribe(this.pubsub_token);
</code></pre><p>  },</p>
<p>render:function(){</p>
<p>return(</p>
<p>You have selected the product : {this.state.selection}</p>
<pre><code>);
</code></pre><p>  }</p>
<p>});</p>
<p>varProduct = React.createClass({</p>
<p>onclick:function(){</p>
<p>PubSub.publish(‘products’, this.props.name);</p>
<p>  },</p>
<p>render:function(){</p>
<p>return</p>
<p>{this.props.name}</p>
<p>;</p>
<p>  }</p>
<p>});</p>
<p>ES6: yield and js-csp</p>
<p>ES6 中有一种传递信息的方式，使用生成函数(generators)和 yield 关键字。可以看一下<a href="https://github.com/ubolonton/js-csp" target="_blank" rel="noopener">https://github.com/ubolonton/js-csp</a></p>
<p>（这里我写一个简单的 DEMO 介绍一下这种新的传递方式，其实大同小异）</p>
<p>function*list(){</p>
<p>for(vari =0; i</p>
<p>yieldarguments[i];</p>
<pre><code>}
</code></pre><p>return”done.”;</p>
<p>}</p>
<p>varo = list(1,2,3);</p>
<p>varcur = o.next;</p>
<p>while(!cur.done) {</p>
<pre><code>cur = o.next();
</code></pre><p>console.log(cur);</p>
<p>}</p>
<p>以上例子来自于屈屈的一篇博客：ES6 中的生成器函数介绍  屈屈是一个大牛，大家可以关注他的博客。</p>
<p>通常来说，你有一个队列，对象在里面都能找到一个引用，在定义的时候锁住，当发生的时候，立即打开锁执行。js-csp 是一种解决办法，也许以后还会有其他解决办法。</p>
<p>结尾</p>
<p>在实际应用中，按照实际要解决的需求选择解决办法。对于小应用程序，你可以使用 props 和回调的方法进行组件之间的数据交换。你可以通过 pub/sub 模式，以避免污染你的组件。在这里，我们不是在谈论数据，只是组件。对于数据的请求、数据的变化等场景，可以使用 Facebook 的 Flux、Relay、GraphQL 来处理，都非常的好用。</p>
<p>文中的每一个例子我都验证过了，主要使用最原始的引入文件方式，创建服务使用的 http-server 包，大家也可以尝试自己来一次。</p>
<p>参考文档:    1. <a href="https://blog.csdn.net/limm33/article/details/50942863" target="_blank" rel="noopener">https://blog.csdn.net/limm33/article/details/50942863</a></p>
<p>2.<a href="https://www.jianshu.com/p/8b845f05cf4b" target="_blank" rel="noopener">https://www.jianshu.com/p/8b845f05cf4b</a></p>
<p>3.<a href="https://blog.csdn.net/genius_yym/article/details/73057248" target="_blank" rel="noopener">https://blog.csdn.net/genius_yym/article/details/73057248</a></p>
<ol start="4">
<li><a href="https://segmentfault.com/q/1010000007295553?_ea=1300560" target="_blank" rel="noopener">https://segmentfault.com/q/1010000007295553?_ea=1300560</a></li>
</ol>
</button>
          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/08/23/react的状态提升/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/react的状态提升/" itemprop="url">react的状态提升.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T11:02:39+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/23/react的状态提升/" class="leancloud_visitors" data-flag-title="react的状态提升.md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.概念理解</strong><br>在react中是单向数据流的设计, 即 只有父组件可以传递数据给子组件,而没有子组件传递数据给父组件的概念. 以正确的技术说明，是 拥有者组件 可以设置 被拥有者组件 中的资料，也就是主人与仆人的关系。</p>
<p>那么子组件要传递数据给父组件该如何沟通呢?</p>
<p>换句话说就是, react 如何将子组件的值暴露让父组件获取到?</p>
<p>可以采用一种迂回的方法, 在父组件中设置一个方法(函数), 将其通过props传递给子组件, 然后在子组件中更新state的状态,并调用父组件中传过来的方法, 将state数据作为参数传递给父组件. 这样, 改变父组件的状态，从而改变受父组件控制的所有子组件的状态. 这就是状态提升的概念.   用官方的原话就是:    ‘共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)’。</p>
<p><strong>官方参考网址: <a href="https://www.css88.com/react/docs/lifting-state-up.html" target="_blank" rel="noopener">https://www.css88.com/react/docs/lifting-state-up.html</a></strong></p>
<p><strong>2.举例说明</strong><br><br><br>下面举个例子说明:</p>
<p>App.js文件   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import  React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">import Item from &apos;./Item&apos;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">        super(props)</span><br><span class="line"></span><br><span class="line">        this.state = &#123;</span><br><span class="line"></span><br><span class="line">            options: [</span><br><span class="line"></span><br><span class="line">                &#123;name:&apos;（1）免费行李&apos;, value: 1 &#125;,</span><br><span class="line"></span><br><span class="line">                &#123;name:&apos;2&apos;, value: 2 &#125;,</span><br><span class="line"></span><br><span class="line">                &#123;name:&apos;3&apos;, value: 3 &#125; ],</span><br><span class="line"></span><br><span class="line">            price: 0</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    changePrice = (value) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        let price = 800</span><br><span class="line"></span><br><span class="line">        if(value === 1)  price = 0</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        price *= value - 1</span><br><span class="line"></span><br><span class="line">        this.setState(&#123;price: price&#125;) &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &#123;this.state.price&#125;</span><br><span class="line"></span><br><span class="line">)  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Item.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export default class Item extends Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">        super(props)</span><br><span class="line"></span><br><span class="line">        this.handleChange = this.handleChange.bind(this)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(e)&#123;</span><br><span class="line"></span><br><span class="line">    this.props.changePrice(e.target.value)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        var options = []</span><br><span class="line"></span><br><span class="line">        var optionArray = this.props.optionArray</span><br><span class="line"></span><br><span class="line">        options = optionArray.map(function(item, index)&#123;</span><br><span class="line"></span><br><span class="line">            return ( &#123;item.name&#125; )</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return ( &#123;options&#125; )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p> <strong>2.1. 先绑定(bind)住render有用到的方法</strong></p>
<p>在父组件与子组件各有用到一个自己的方法changePrice，并在render中作赋值，在React中需要bind过才会把this对住，因为在render的return语句中使用，它在重渲染(re-render)时会再次建立新的方法(函数)内容值，这样会有效能上的影响，所以要先作绑定的事，然后再render的return里面用。关于bind(this)的一些理解,在我的另一篇文章,可以参考:<a href="https://www.jianshu.com/p/f7f2636d16a9" target="_blank" rel="noopener">https://www.jianshu.com/p/f7f2636d16a9</a></p>
<p>先绑定要在类的contructor里作，像下面这样，我这写一个父组件而已，子组件一样:</p>
<p>constructor(props) {super(props)this.state = {price:0}//先bind类中方法this.changePrice =this.changePrice.bind(this)  }</p>
<p>之后在render的return要改成这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return(</span><br><span class="line">	&lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.2 校正state(状态)里的资料，以及提升到父组件去</strong></p>
<p>在子组件中的state(状态)中的资料是不是有那么必要放在子组件中，如果你还有第二个子组件、第三、第四…，它们都要用例如这里的选中资料，你放在这个子组件是违反了上面说的应用领域全局资料思维的。</p>
<p>先看一下子组件目前的state，是长这个样子:</p>
<pre><code>this.state = {names: [&apos;（1）免费行李&apos;,&apos;2&apos;,&apos;3&apos;],values: [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;],selectName:&apos;&apos;,prices:&apos;0&apos;}
</code></pre><p>这里要先校正一下，names与values是代表选项中的名与值，它们是有关联的，所以应该是这样的下面结构才是好些的，value如果是要用来代表数字，就用数字就行不需要用字串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options: [  &#123;name:&apos;（1）免费行李&apos;,value:1&#125;,  &#123;name:&apos;2&apos;,value:2&#125;,  &#123;name:&apos;3&apos;,value:3&#125;]</span><br></pre></td></tr></table></figure>
<p>选中了哪个选项这个状态资料，还是要先放在子组件中，因为子组件中有选项盒，与触发的更动方法，但选项的资料可以移到上层的父组件中:</p>
<p>这是上层App.js中的状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">	options: [</span><br><span class="line">		&#123;name:&apos;（1）免费行李&apos;,value:1&#125;,</span><br><span class="line">		&#123;name:&apos;2&apos;,value:2&#125;,  </span><br><span class="line">		&#123;name:&apos;3&apos;,value:3&#125;],</span><br><span class="line">	price:0</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>父组件也改用把state里面的选项值，用props值给子组件，所以在render里语句改成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件中这时可以用this.props.optionArray接到传入的选项值，所以在render方法中，改用这个来代替之前的this.state.names与this.state.values，简单改写如下:</p>
<p>varoptions = []varprices =this.state.pricesvaroptionArray =this.props.optionArrayfor(vari =0; i&lt; optionArray.length; i++) {      options.push({optionArray[i].name})  }</p>
<p>注: 这里不用for…in语句而用for语句，是因为for…in语句是个不建议用在数组资料的语法，它并不会保证取到数组成员里的顺序。for…in只会用在对象的寻遍中。</p>
<p>更精简的写法是用Array.map，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var options = []</span><br><span class="line">var prices =this.state.prices</span><br><span class="line">var optionArray =this.props.optionArray</span><br><span class="line">options = optionArray.map(function(item, index)&#123;return(&#123;item.name&#125;)&#125;)</span><br></pre></td></tr></table></figure>
<p>接着，如果依选项选中然后计算价格这件事，规划中应该是整个应用来作的，例如有可能还有其他的组件中也有其他的选项，最后统一要来算价格，所以计算价格这件事，也应该放到父组件去，所以如同上面的改写一样，把子组件的prices状态与相关计算的代码，都提到父组件，这个子组件纯用来当选项盒用而已。子组件此时连state都可以不用有。</p>
<p>因为整个改写过的代码会多些，所以我把父组件与子组件中的代码整个贴上。</p>
<p>父组件App.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Item from&apos;./Item&apos;</span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">	super(props)</span><br><span class="line">	this.state = &#123;options: [ &#123;name:&apos;（1）免费行李&apos;,value:1&#125;,        &#123;name:&apos;2&apos;,value:2&#125;,        &#123;name:&apos;3&apos;,value:3&#125;   ],price:0&#125;</span><br><span class="line">	this.changePrice =this.changePrice.bind(this)  </span><br><span class="line">&#125;  </span><br><span class="line">changePrice(value)&#123;</span><br><span class="line">	var price =800;</span><br><span class="line">	if(value ===1) </span><br><span class="line">	price =0 </span><br><span class="line">	else</span><br><span class="line">	price = (value -1) * price</span><br><span class="line">	this.setState(&#123;price: price&#125;)  &#125;  </span><br><span class="line">render() &#123;</span><br><span class="line">	return(</span><br><span class="line">	&lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">	)  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>子组件Item.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125;from&apos;react&apos;</span><br><span class="line">export default class Item extends Component&#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props)</span><br><span class="line">	&#125;  </span><br><span class="line">	handleChange(e)&#123;</span><br><span class="line">		this.props.changePrice(e.target.value)  </span><br><span class="line">	&#125;  </span><br><span class="line">	render() &#123;</span><br><span class="line">	var options = []</span><br><span class="line">	var optionArray =this.props.optionArray    </span><br><span class="line">	options = optionArray.map(function(item, index)&#123;return(&#123;item.name&#125;)    &#125;)return(</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;options&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">)  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.3. 目前最终进化版本</strong></p>
<p>这个版本有几个改进如下，供参考:</p>
<p>用let/const取代var。</p>
<p>不用分号(;)作为语句结尾。</p>
<p>Item子组件改用函数定义方式，取代原先的组件定义方式。</p>
<p>能合并的语句都合并。</p>
<p>函数全用箭头函数(注意需额外加装babel-plugin-transform-class-properties)。</p>
<p>App.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125;from&apos;react&apos;</span><br><span class="line">import Item from&apos;./Item2&apos;</span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props)</span><br><span class="line">		this.state = &#123;options: [ </span><br><span class="line">		&#123;name:&apos;（1）免费行李&apos;,value:1&#125;,</span><br><span class="line">		&#123;name:&apos;2&apos;,value:2&#125;, </span><br><span class="line">		&#123;name:&apos;3&apos;,value:3&#125;],</span><br><span class="line">  changePrice =(value) =&gt;&#123;</span><br><span class="line">	  let price =800</span><br><span class="line">	  if(value ===1) </span><br><span class="line">		  price =0</span><br><span class="line">	  else</span><br><span class="line">	  price *= value -1</span><br><span class="line">render() &#123;</span><br><span class="line">	return(</span><br><span class="line"></span><br><span class="line">	&lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">	</span><br><span class="line">	)  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Item.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from&apos;react&apos;</span><br><span class="line">const Item =(props) =&gt;&#123;</span><br><span class="line">const optionArray = props.optionArray</span><br><span class="line">const options = optionArray.map((item, index) =&gt;&#123;return(&#123;item.name&#125;)  &#125;)return(</span><br><span class="line"></span><br><span class="line">&#123;props.changePrice(e.target.value)&#125;&#125;&gt;  &#123;options&#125;</span><br><span class="line"></span><br><span class="line">)&#125;</span><br><span class="line">export default Item</span><br></pre></td></tr></table></figure>
<p><br><br><strong>3.参考文档</strong><br><br><br>参考文档: 1. <a href="https://www.cnblogs.com/zhangbob/p/6962138.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/zhangbob/p/6962138.html?utm_source=itdadao&amp;utm_medium=referral</a></p>
<ol start="2">
<li><a href="https://www.css88.com/react/docs/lifting-state-up.html官方文档" target="_blank" rel="noopener">https://www.css88.com/react/docs/lifting-state-up.html官方文档</a></li>
</ol>
<p>3.<a href="https://blog.csdn.net/YQXLLWY/article/details/73481063" target="_blank" rel="noopener">https://blog.csdn.net/YQXLLWY/article/details/73481063</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/07/15/js-将图片资源转码成base64的各种场景及其实现/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/15/js-将图片资源转码成base64的各种场景及其实现/" itemprop="url">js 将图片资源转码成base64的各种场景及其实现</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-15T14:55:03+08:00">
                2017-07-15
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/07/15/js-将图片资源转码成base64的各种场景及其实现/" class="leancloud_visitors" data-flag-title="js 将图片资源转码成base64的各种场景及其实现">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>前言:</strong><br>在项目中,经常会遇到要转码转成base64的场景, 那么什么是base64呢? 为什么要转成base64编码呢?</p>
<p>在<a href="https://javascript.ruanyifeng.com/grammar/string.html#toc6" target="_blank" rel="noopener">阮一峰大神的JavaScript文档</a>中是这么说的:</p>
<blockquote>
<p> 有时，文本里面包含一些不可打印的符号，比如 ASCII 码0到31的符号都无法打印出来，这时可以使用 Base64<br>编码，将它们转成可以打印的字符。<br>另一个场景是，有时需要以文本格式传递二进制数据，那么也可以使用 Base64 编码。<br><br><br>所谓 Base64 就是一种编码方法，可以将任意值转成0～9、A～Z、a-z、+和/这64个字符组成的可打印字符。<br>使用它的主要目的，不是为了加密，而是为了不出现特殊字符，简化程序的处理。</p>
</blockquote>
<p><br><br>但这篇文章的重点不是介绍base64, 下面主要还是说说图片资源在什么情况下要使用到base64转码吧<br><br><br><strong>场景一：将用户本地上传的资源转化，即用户通过浏览器点击文件上传时，将图片资源转化成base64：</strong></p>
<p><input type="file" id="image"><br></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">var reader = new FileReader();</span><br><span class="line">        var AllowImgFileSize = 2100000; //上传图片最大值(单位字节)（ 2 M = 2097152 B ）超过2M上传失败</span><br><span class="line">        var file = $(&quot;#image&quot;)[0].files[0];</span><br><span class="line">        var imgUrlBase64;</span><br><span class="line">        if (file) &#123;</span><br><span class="line">            //将文件以Data URL形式读入页面  </span><br><span class="line">            imgUrlBase64 = reader.readAsDataURL(file);</span><br><span class="line">            reader.onload = function (e) &#123;</span><br><span class="line">              //var ImgFileSize = reader.result.substring(reader.result.indexOf(&quot;,&quot;) + 1).length;//截取base64码部分（可选可不选，需要与后台沟通）</span><br><span class="line">              if (AllowImgFileSize != 0 &amp;&amp; AllowImgFileSize &lt; reader.result.length) &#123;</span><br><span class="line">                    alert( &apos;上传失败，请上传不大于2M的图片！&apos;);</span><br><span class="line">                    return;</span><br><span class="line">                &#125;else&#123;</span><br><span class="line">                    //执行上传操作</span><br><span class="line">                    alert(reader.result);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">         &#125;</span><br></pre></td></tr></table></figure>
<p> <strong>场景二：将本项目中的图片资源转化成base64,（我还没有用到过此场景，感觉场景二也可以通过场景三来实现）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">   var url = &quot;static/img/js1.jpg&quot;;//这是站内的一张图片资源，采用的相对路径</span><br><span class="line">   convertImgToBase64(url, function(base64Img)&#123;</span><br><span class="line">    //转化后的base64</span><br><span class="line">    alert(base64Img);</span><br><span class="line">   &#125;);             </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//实现将项目的图片转化成base64</span><br><span class="line">function convertImgToBase64(url, callback, outputFormat)&#123;</span><br><span class="line">   var canvas = document.createElement(&apos;CANVAS&apos;),</span><br><span class="line">　　ctx = canvas.getContext(&apos;2d&apos;),</span><br><span class="line">　　img = new Image;</span><br><span class="line">　　img.crossOrigin = &apos;Anonymous&apos;;</span><br><span class="line">　　img.onload = function()&#123;</span><br><span class="line">    　　canvas.height = img.height;</span><br><span class="line">    　　canvas.width = img.width;</span><br><span class="line">    　　ctx.drawImage(img,0,0);</span><br><span class="line">    　　var dataURL = canvas.toDataURL(outputFormat || &apos;image/png&apos;);</span><br><span class="line">    　　callback.call(this, dataURL);</span><br><span class="line">    　　canvas = null; </span><br><span class="line">    &#125;;</span><br><span class="line">　　img.src = url;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>场景三：将网络图片资源转化为base64，（感觉场景二中的资源换成绝对路径即可使用在场景三中）</strong></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">function()&#123;</span><br><span class="line">　　 //这是网上的一张图片链接</span><br><span class="line">　　 var url=&quot;https://p1.pstatp.com/large/435d000085555bd8de10&quot;;</span><br><span class="line">    getBase64(url)</span><br><span class="line">        .then(function(base64)&#123;</span><br><span class="line">              console.log(base64);//处理成功打印在控制台</span><br><span class="line">        &#125;,function(err)&#123;</span><br><span class="line">              console.log(err);//打印异常信息</span><br><span class="line">        &#125;);                        </span><br><span class="line">&#125;    </span><br><span class="line"></span><br><span class="line">//传入图片路径，返回base64</span><br><span class="line">function getBase64(img)&#123;</span><br><span class="line">    function getBase64Image(img,width,height) &#123;//width、height调用时传入具体像素值，控制大小 ,不传则默认图像大小</span><br><span class="line">      var canvas = document.createElement(&quot;canvas&quot;);</span><br><span class="line">      canvas.width = width ? width : img.width;</span><br><span class="line">      canvas.height = height ? height : img.height;</span><br><span class="line"> </span><br><span class="line">      var ctx = canvas.getContext(&quot;2d&quot;);</span><br><span class="line">      ctx.drawImage(img, 0, 0, canvas.width, canvas.height);</span><br><span class="line">      var dataURL = canvas.toDataURL();</span><br><span class="line">      return dataURL;</span><br><span class="line">    &#125;</span><br><span class="line">    var image = new Image();</span><br><span class="line">    image.crossOrigin = &apos;&apos;;</span><br><span class="line">    image.src = img;</span><br><span class="line">    var deferred=$.Deferred();</span><br><span class="line">    if(img)&#123;</span><br><span class="line">      image.onload =function ()&#123;</span><br><span class="line">        deferred.resolve(getBase64Image(image));//将base64传给done上传处理</span><br><span class="line">      &#125;</span><br><span class="line">      return deferred.promise();//问题要让onload完成后再return sessionStorage[&apos;imgTest&apos;]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>至此，便将图片base64转码的三种场景介绍完毕了，下面是基于以上的一下拓展：</p>
<p><strong>扩展:</strong><br><strong>拓展一：后台需要以纯字符串的形式上传（即去掉data:image/png;base64，截取字符串即可）</strong></p>
<p>reader.result.substring(reader.result.indexOf(“,”) + 1)<br><strong>拓展二：判断base64资源大小，超过2M不让上传</strong></p>
<pre><code>var AllowImgFileSize = 2100000;    //上传图片最大值(单位字节)（ 2 M = 2097152 B ）
if (AllowImgFileSize != 0 &amp;&amp; AllowImgFileSize &lt; reader.result.length) {
  alert( &apos;上传失败，请上传不大于2M的图片！&apos;);
  return;
}
</code></pre><p>其中reader.result即是base64转码后的结果。</p>
<p>附上一篇 参考文档: <a href="https://blog.csdn.net/tww316/article/details/44343075" target="_blank" rel="noopener">https://blog.csdn.net/tww316/article/details/44343075</a><br><br><br>JavaScript 图片上传后base64转码直接显示<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">// 获取文件流</span><br><span class="line">var fileObj = document.getElementById(&apos;inputId&apos;).files;</span><br><span class="line">// 实例化一个FileReader对象</span><br><span class="line">var reader = new FileReader();</span><br><span class="line">	// 创建一个img</span><br><span class="line">var img = $(&apos;&lt;img /&gt;&apos;);</span><br><span class="line">reader.onload = function (e) &#123;</span><br><span class="line">	img.attr(&apos;src&apos;, e.target.result);</span><br><span class="line">	$(&apos;div-selector&apos;).append(img); </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">// base64转码</span><br><span class="line">reader.readAsDataURL(fileObj);</span><br></pre></td></tr></table></figure></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/07/08/为什么要将script脚本放在body底部/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/07/08/为什么要将script脚本放在body底部/" itemprop="url">为什么要将script脚本放在body底部</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-07-08T15:01:50+08:00">
                2017-07-08
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/07/08/为什么要将script脚本放在body底部/" class="leancloud_visitors" data-flag-title="为什么要将script脚本放在body底部">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>说明：</strong></p>
<p>本文提到的浏览器均是指Chrome。<br>“script标签“指的都是普通的不带其他属性的外联javascript。<br>web性能优化的手段并不是非黑即白的，有些手段过头了反而降低性能，所以在讨论条件和结论的时候，虽然很多条件本身会带来其他细微的负面或正面影响，为了不使论述失去重点，不会扩展太开。<br>一、从一个面试题说起<br>面试前端的时候我喜欢问一些看上去是常识的问题。比如：为什么大家普遍把<script src=""></script>这样的代码放在body最底部？（为了沟通效率，我会提前和对方约定所有的讨论都以chrome为例）</p>
<p>应聘者一般会回答：因为浏览器生成Dom树的时候是一行一行读HTML代码的，script标签放在最后面就不会影响前面的页面的渲染。</p>
<p>我很鸡贼地接着问：既然Dom树完全生成好后页面才能渲染出来，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样？</p>
<p>留<br>一<br>段<br>空<br>白<br>让<br>你<br>先<br>想<br>一<br>想</p>
<p>这其实是个开放性的问题，里面涉及的概念的界定本身就很重要。</p>
<p>“页面渲染出来了” 指的是什么？<br>严格来说，我的最后一问是有歧义的：我们需要统一一下什么叫我们经常挂在嘴边的“页面渲染出来了” —— 指的是是 “首屏显示出来了” 还是 “页面完整地加载好了”（后面统称StepC） ？<br>如果指的是首屏显示出来了，那么问题又来了：假设网页首屏有图片，这里的“首屏” 指的是 “显示了全部图片的首屏”（后面统称StepB） 还是 “没有图片的首屏”（后面统称StepA）。</p>
<p>确定清楚 “页面渲染出来了” 指的是 StepA、StepB、StepC 中的哪一个是非常关键的（虽然至今还没有一个应聘者尝试这么做过），如果 “页面渲染出来了” 指的是 StepC，那么我的最后一问的答案是肯定的——script标签不放在body底部不会拖慢页面完整地加载好的时间。</p>
<p>显然，我们往往更关心首屏时间，所以，如果 “页面渲染出来了” 特指“没有图片的首屏”，那我的最后一问变成了下面这样，又该如何回答呢？</p>
<p>既然Dom树完全生成好后才能显示“没有图片的首屏”，浏览器又必须读完全部HTML才能生成完整的Dom树，script标签不放在body底部是不是也一样？</p>
<p>陷阱<br>然而上面的问题还是存在一个陷阱——既然Dom树完全生成好后才能显示“没有图片的首屏”这句话是带欺骗性的，“没有图片的首屏”并不以“完整的Dom树”为必要条件。也就是说：在生成Dom树的过程中只要某些条件具备了，“没有图片的首屏”就能显示出来。</p>
<p>所以，抛开这些歧义和陷阱，我的问题变成了：</p>
<p>script标签的位置会影响首屏时间么？</p>
<p>然而答案并不是那么显而易见，这得从浏览器的渲染机制说起。（再一次说明：本文所说的浏览器都是指chrome）</p>
<p>二、浏览器的渲染机制<br>Google Web Fundamentals 是一个非常优秀的文档，里面讲到了跟web、浏览器、前端的方方面面。我总结一下其中的 Ilya Grigorik 写的 Critical rendering path 浏览器渲染机制部分的内容如下：</p>
<p>几个概念</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">1、DOM：Document Object Model，浏览器将HTML解析成树形的数据结构，简称DOM。</span><br><span class="line"></span><br><span class="line">2、CSSOM：CSS Object Model，浏览器将CSS代码解析成树形的数据结构。</span><br><span class="line"></span><br><span class="line">3、DOM 和 CSSOM 都是以 Bytes → characters → tokens → nodes → object model. 这样的方式生成最终的数据。如下图所示：</span><br><span class="line"></span><br><span class="line">bVsaO</span><br><span class="line"></span><br><span class="line">DOM 树的构建过程是一个深度遍历过程：当前节点的所有子节点都构建好后才会去构建当前节点的下一个兄弟节点。</span><br><span class="line"></span><br><span class="line">4、Render Tree：DOM 和 CSSOM 合并后生成 Render Tree，如下图：</span><br></pre></td></tr></table></figure>
<p>bVsaP</p>
<p>Render Tree 和DOM一样，以多叉树的形式保存了每个节点的css属性、节点本身属性、以及节点的孩子节点。</p>
<p>注意：display:none 的节点不会被加入 Render Tree，而 visibility: hidden 则会，所以，如果某个节点最开始是不显示的，设为 display:none 是更优的。（具体可以看这里）</p>
<p>浏览器的渲染过程<br>Create/Update DOM And request css/image/js：浏览器请求到HTML代码后，在生成DOM的最开始阶段（应该是 Bytes → characters 后），并行发起css、图片、js的请求，无论他们是否在HEAD里。</p>
<blockquote>
<p>注意：发起 js 文件的下载 request 并不需要 DOM 处理到那个 script<br>节点，比如：简单的正则匹配就能做到这一点，虽然实际上并不一定是通过正则：）。这是很多人在理解渲染机制的时候存在的误区。</p>
</blockquote>
<p>Create/Update Render CSSOM：CSS文件下载完成，开始构建CSSOM<br>Create/Update Render Tree：所有CSS文件下载完成，CSSOM构建结束后，和 DOM 一起生成 Render Tree。<br>Layout：有了Render Tree，浏览器已经能知道网页中有哪些节点、各个节点的CSS定义以及他们的从属关系。<br>下一步操作称之为Layout，顾名思义就是计算出每个节点在屏幕中的位置。<br>Painting：Layout后，浏览器已经知道了哪些节点要显示（which nodes are visible）、每个节点的CSS属性是什么（their computed styles）、每个节点在屏幕中的位置是哪里（geometry）。就进入了最后一步：Painting，按照算出来的规则，通过显卡，把内容画到屏幕上。<br>以上五个步骤前3个步骤之所有使用 “Create/Update” 是因为DOM、CSSOM、Render Tree都可能在第一次Painting后又被更新多次，比如JS修改了DOM或者CSS属性。</p>
<p>Layout 和 Painting 也会被重复执行，除了DOM、CSSOM更新的原因外，图片下载完成后也需要调用Layout 和 Painting来更新网页。</p>
<p>看 Timeline，一目了然<br>我扒了一段有赞PC首页的代码到本地，通过Node跑起来。Node作为Server端，对/js/jquery.js 做了延时2s返回的处理，并且把<script src="https://127.0.0.1:8080/js/jquery.js"></script> 放到导航栏的下面，结果是这样的：</p>
<p>bVsaO</p>
<p>bVsaO</p>
<p>bVsaO</p>
<p>bVsaO</p>
<p>从上面的Timeline我们可以看出：</p>
<p>首屏时间和DomContentLoad事件没有必然的先后关系<br>所有CSS尽早加载是减少首屏时间的最关键<br>js的下载和执行会阻塞Dom树的构建（严谨地说是中断了Dom树的更新），所以script标签放在首屏范围内的HTML代码段里会截断首屏的内容。<br>script标签放在body底部，做与不做async或者defer处理，都不会影响首屏时间，但影响DomContentLoad和load的时间，进而影响依赖他们的代码的执行的开始时间。<br>三、问题的答案<br>回到前面的问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">script标签的位置会影响首屏时间么？</span><br></pre></td></tr></table></figure>
<p>答案是：不影响（如果这里里的首屏指的是页面从白板变成网页画面——也就是第一次Painting），但有可能截断首屏的内容，使其只显示上面一部分。</p>
<p>为什么说是“有可能”呢？，如果该js下载地比css还快，或者script标签不在第一屏的html里，实际上是不影响的。明白这一影响边界非常重要，这样我们在考察页面性能瓶颈的时候就有的放矢了。举个例子：在网页的第二屏有一个通用模块，实际上我们是可以把它的js逻辑独立成一个文件，将模块的html和js标签放在一起做成独立的模板引进来的（如果它的js比较小或者说因为多了一个文件会多占用一个TCP连接和带宽，这实际上是另外一个话题了，请参考我文章开头的声明）。</p>
<p>四、总结、再进一步<br>所以，总算弄清楚这个众所周知的常识了。我们来总结一下：</p>
<blockquote>
<p>如果script标签的位置不在首屏范围内，不影响首屏时间 所有的script标签应该放在body底部是很有道理的<br>但从性能最优的角度考虑，即使在body底部的script标签也会拖慢首屏出来的速度，<br>因为浏览器在最一开始就会请求它对应的js文件，而这，占用了有限的TCP链接数、带宽甚至运行它所需要的CPU。<br>这也是为什么script标签会有async或defer属性的原因之一。</p>
</blockquote>
<p>可是，在复杂的实际应用场景中，要贯彻这几条结论可能会遇到问题，比如：</p>
<p>你的页面是分模块来写的，每一个模块都有自己的html、js甚至css，当把这些模块凑到一个页面中的时候就会出现js自然而然地出现在HTML中间部分。你很难把script标签都放到底部<br>即使你把script标签都放到底部，但script标签的存在终究是拖慢了首屏时间、DomContendLoad和loaded的时间。如果只有一个script标签，我们可以加一个async，但多个async的script标签的结果会是js文件被乱序执行的，这显然不是我们想要的。<br>我们也遇到了这样的问题，所以就做了一个开源项目：Tiny-Loader —— A small loader that load CSS/JS in best way for page performance 简单好用。</p>
<p>来自：<a href="https://blog.csdn.net/garvisjack/article/details/71077986#t1" target="_blank" rel="noopener">https://blog.csdn.net/garvisjack/article/details/71077986#t1</a></p>
<p>相关文章<br><a href="https://caibaojian.com/toutiao/6171" target="_blank" rel="noopener">聊聊前端排序的那些事</a> 601Views</p>
<p><a href="https://caibaojian.com/toutiao/6547" target="_blank" rel="noopener">浏览器的布局绘制与DOM操作</a>  214Views<br><a href="https://caibaojian.com/toutiao/5111" target="_blank" rel="noopener">小技巧：一行代码让浏览器瞬间变成临时编辑器</a> 761Views<br><a href="https://caibaojian.com/toutiao/6648" target="_blank" rel="noopener">浅析渲染引擎与前端优化</a> 245Views<br><a href="https://blog.csdn.net/lumeier/article/details/46398009" target="_blank" rel="noopener">JS放在head和放在body中的区别</a>   286Views</p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/03/25/记录博客搭建踩过的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/25/记录博客搭建踩过的坑/" itemprop="url">记录博客搭建踩过的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-25T14:47:58+08:00">
                2017-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/博客搭建/" itemprop="url" rel="index">
                    <span itemprop="name">博客搭建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/25/记录博客搭建踩过的坑/" class="leancloud_visitors" data-flag-title="记录博客搭建踩过的坑">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本人的博客使用的是hexo+github搭建的一套独立博客, 主题采用的是next,经过两天的折腾, 博客也弄得有模有样了.(微笑).<br>现在记录一下踩过的坑,希望自己可以好好总结, 能帮助到萌新就更好了,哈哈!<br>问题不分顺序,本人比较懒, 想到啥就写啥.</p>
<p><strong>1.解决编辑器的问题</strong><br>  hexo是使用markdown编辑器的,如果不想在本地安装markDown,(我就懒得安装), 那么CSDN了解一下.<br>  在CSDN写文章的编辑器中 , 切换成markDown, 编辑完之后选择导出到本地, 然后将这个文件放置到你的相应文件夹下, 搞定 .</p>
<p><strong>2.给hexo博客添加系列文章功能</strong><br>之前已经讲过, hexo new page categories 便可以新建一个categories页面,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-03-02 12:33:16</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>实际上调用hexo new page xxx后，会在/source/categories/目录下生成一个index.md文档，在此文档头部加上上面这段即可。实际上，index.md里只需要有这个声明即可，其他内容并不会显示出来，写了也没用。<br>(1)新建文章<br>hexo new ‘文章名’<br>(2)设置分类<br>这一步是重点了, 在上一步中,我们可以看到已经创建了一个 ‘文章名.md’的文件,在source/_posts文件夹下可以找到.<br>大概长这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:  记录博客搭建踩过的坑</span><br><span class="line">date: 2017-03-25 14:47:58</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>你只需要在tags标签下添加分类名称就可以了,像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">categories: 博客搭建</span><br></pre></td></tr></table></figure>
<p>PS. 无论是page，还是post的文章，都是以.md格式结尾，在hexo g的过程中会产生对应的.html文档，然后hexo d到Github上的也只是html文档，不是.md格式的文档。<br>另外就是，需要注意一点：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-03-02 12:33:16</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p><strong>3.HEXO 出现 &gt; -bash: hexo: command not found</strong></p>
<p>在执行hexo deploy的时候一直出现ERROR Deployer not found: git。<br>_config.yml是配置文件,见下图：hexo在2点几的版本中type: github。之后的版本是type: git<br><img src="https://img-blog.csdn.net/20180704164154206?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>解决方法:</p>
<blockquote>
<p>npm install hexo-deployer-git –save<br>hexo d -g</p>
</blockquote>
<p><strong>4.将博客部署到github pages出问题</strong></p>
<p>最常见的就是两个问题, (1)ssh Key的问题, (2) github上setting的问题<br>如何部署就不说了, 这里贴上两篇教程 ,<a href="https://blog.csdn.net/u011974987/article/details/51331822/" target="_blank" rel="noopener">https://blog.csdn.net/u011974987/article/details/51331822/</a><br><a href="https://www.cnblogs.com/imapla/p/5533000.html" target="_blank" rel="noopener">https://www.cnblogs.com/imapla/p/5533000.html</a></p>
<p>(1)ssh Key的问题<br><img src="https://img-blog.csdn.net/20180704153412384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>照着<a href="https://www.jianshu.com/p/301afa16f471" target="_blank" rel="noopener">这篇教程,</a> 重新生成一个sshKey, 并将公钥放置到你的仓库中.</p>
<p>(2)setting的问题</p>
<p>这里需要说明的是, github需要设置pages的仓库名称, 必须是以io结尾的., 这个命名也是个坑, 格式必须是youname.github.io这种。其次youname必须是你的github的用户名.<br>在仓库的setting的options中,找到GitHub Pages模块,在source中选择分支,并点击保存,再刷新页面就会看到有一个网址, 类似这样:<br><img src="https://img-blog.csdn.net/20180704161327622?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>如果是需要在README.md中查看到博客网址的话,可以在README.md中使用一个a标签,href链接地址就是这个红色框的地址. 如果是其他仓库,则需要加上index.html索引文件 .<br>如果没有出现上面所说的网址,打开链接的错误地址,如果是遇到下面这个问题 :<br><img src="https://img-blog.csdn.net/2018070416323750?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>很明显,是部署失败了, 那么就重新部署吧.<br>部署之前一定要安装这个包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
<p>然后执行 hexo d -g</p>
<p>5.空格问题<br>需要注意的是,在_config.yml配置文件中,属性名和属性值之间一定要有一个空格<br>不然你会遇到类似下面这种问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误提示：FATAL bad indentation of a mapping entry at line 72, column 7:</span><br></pre></td></tr></table></figure></p>
<p>或者这种问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误提示：</span><br><span class="line">You should configure deployment settings in _config.yml first!</span><br><span class="line">Available deployer plugins:</span><br><span class="line">  git</span><br><span class="line">For more help, you can check the online docs: https://hexo.io/</span><br></pre></td></tr></table></figure>
<p>6.404可能原因<br>(1).域名解析错误。</p>
<p>检查： windows下cmd命令符输入ping cheatlys.info（你的域名） 看一下ip地址，在ping一下你github上的，ping liuyongshun.github.io看一下是否一样，并且没有请求超时。</p>
<p>(2).你的域名是通过国内注册商注册的，因没有实名制而无法访问。</p>
<p>(3).浏览器缓存，路由器缓存。可尝试清除浏览器缓存再访问或者换个浏览器访问，或者换个局域网访问。</p>
<p>(4). 你的hexo配置有问题，而导致index页面在主域名的下一级目录。找到index页面，在域名后面添加下一级目录。看是否能访问index页面（此时样式可能是乱的）。直接在.github.io的库（相当于根目录，在_config.yml配置root时直接是/如果这些内容在blog下，root应该是/blog/）下边展开这些内容。<br><img src="https://img-blog.csdn.net/2018070416543571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>7.绑定域名<br>你需要在本地的source下建立CNAME文件(是文件不是文件夹也没有拓展名)，内容就是你买的的域名（例：不要<a href="http://www.cheatlys.info，而是写cheatlys.info前者直接输入cheatlys.info不会连接到你的网站。）" target="_blank" rel="noopener">www.cheatlys.info，而是写cheatlys.info前者直接输入cheatlys.info不会连接到你的网站。）</a></p>
<p>暂时先写到这里啦,后面想起来再写,</p>
<p><strong>补充日常博客管理</strong><br><strong>日常修改</strong><br>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>
<p>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br>然后才执行hexo generate -d发布网站到master分支上。<br>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<p><strong>本地资料丢失</strong><br>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<p>使用git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；<br>在本地新拷贝的CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="大鱼吃小鱼@" />
            
              <p class="site-author-name" itemprop="name">大鱼吃小鱼@</p>
              <p class="site-description motion-element" itemprop="description">记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">12</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">2</span>
                  <span class="site-state-item-name">标签</span>
                
              </div>
            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yidongying" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/yi-dong-ying-72/activities" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5222949342/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/59a532a6f265da248b04ebda" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-globe"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情连接
              </div>
              <ul class="links-of-blogroll-list">
               
                <span class="links-of-author-item" style="text-align:left">
                  <a href="https://github.com/yidongying/web_front_source" title="学习资源收集" target="_blank">
                    学习资源收集
                  </a>
                </span>
              
                <span class="links-of-author-item" style="text-align:left">
                  <a href="https://www.colabug.com/2303894.html" title="开发指南指引" target="_blank">
                    开发指南指引
                  </a>
                </span>
              
                <span class="links-of-author-item" style="text-align:left">
                  <a href="https://yidongying.github.io/2017/03/22/hello-world/" title="博客搭建指导" target="_blank">
                    博客搭建指导
                  </a>
                </span>
              
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大鱼吃小鱼@</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("inY1AtIRYvoTTvLxcFHkLbd4-gzGzoHsz", "KY2YVwAqi9L9bNB8RU2kLRx6");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
