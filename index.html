<!DOCTYPE html>



  


<html class="theme-next pisces use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹">
<meta name="keywords" content="小鱼 前端 程序媛 码农 工程师">
<meta property="og:type" content="website">
<meta property="og:title" content="易冬英的博客">
<meta property="og:url" content="https://yidongying.github.io/index.html">
<meta property="og:site_name" content="易冬英的博客">
<meta property="og:description" content="记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="易冬英的博客">
<meta name="twitter:description" content="记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Pisces',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="https://yidongying.github.io/"/>





  <title>易冬英的博客</title>
  








</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">易冬英的博客</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">大鱼吃小鱼</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            分类
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            关于
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            站点地图
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2018/02/05/你真的了解箭头函数吗/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/02/05/你真的了解箭头函数吗/" itemprop="url">深入浅出ES6(一): 你真的了解箭头函数吗</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2018-02-05T20:09:15+08:00">
                2018-02-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/深入浅出ES6/" itemprop="url" rel="index">
                    <span itemprop="name">深入浅出ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2018/02/05/你真的了解箭头函数吗/" class="leancloud_visitors" data-flag-title="深入浅出ES6(一): 你真的了解箭头函数吗">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>前言<br>这个系列主要是说明ES6的新特性,从2015年到现在,es6出来也有挺长一段时间了,在项目中也在普遍使用这些特性.,网上的写es6的文章也大把, 但我感觉可能还是停留在会用的阶段,,至于为什么要这么用, 又为什么会出现这个特性,解决了什么样的问题,这些都有些一知半解. 所以,打算抽时间去了解es6未知的一面.<br>这篇文章,就先从用的最多的箭头函数开始-&gt;</p>
<p><strong>箭头函数的由来</strong><br><strong>为什么叫箭头函数?</strong><br>因为,它的定义用的是一个箭头.<br>那为什么要用一个箭头?<br>先来看一段代码:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;script language=&quot;javascript&quot;&gt;</span><br><span class="line">  &lt;!--</span><br><span class="line">    document.bgColor = &quot;brown&quot;;  // red</span><br><span class="line">  // --&gt;</span><br><span class="line">  &lt;/script&gt;</span><br></pre></td></tr></table></figure>
<p>有没觉得很奇怪?在注释里边的代码也有效?当然,如果知道注释风格的代码的人,应该可以理解.</p>
<p>箭头符号在JavaScript诞生时就已经存在，当初第一个JavaScript教程曾建议在HTML注释内包裹行内脚本，这样可以避免不支持JS的浏览器误将JS代码显示为文本。</p>
<p>老式浏览器会将这段代码解析为两个不支持的标签和一条注释，只有新式浏览器才能识别出其中的JS代码。</p>
<p>为了支持这种奇怪的hack方式，浏览器中的JavaScript引擎将<code>&lt;!--</code>这四个字符解析为单行注释的起始部分，我没开玩笑，这自始至终就是语言的一部分，直到现在仍然有效, 这种注释符号不仅出现<code>&lt;script&gt;</code>标签后的首行，在JS代码的每个角落你都有可能见到它，甚至在Node中也是如此。</p>
<p>碰巧，这种注释风格首次在ES6中被标准化了，但在新标准中箭头被用来做其它事情。</p>
<p>箭头序列–&gt;同样是单行注释的一部分。古怪的是，在HTML中–&gt;之前的字符是注释的一部分，而在JS中–&gt;之后的部分才是注释。</p>
<p>你一定感到陌生的是，只有当箭头在行首时才会注释当前行。这是因为在其它上下文中，–&gt;是一个JS运算符：<code>“趋向于”运算符！</code></p>
<blockquote>
<p>function countdown(n) {<br>      while (n –&gt; 0)  // “n goes to zero”<br>        alert(n);<br>      blastoff();<br>    }</p>
</blockquote>
<p>上面这段代码可以正常运行，循环会一直重复直到n趋于0，这当然不是ES6中的新特性，它只不过是将两个你早已熟悉的特性通过一些误导性的手段结合在一起。你能理解么？通常来说，类似这种谜团都可以在Stack Overflow上找到答案。</p>
<p>当然，同样地，小于等于操作符&lt;=也形似箭头，你可以在JS代码、隐藏的图片样式中找到更多类似的箭头，但是我们就不继续寻找了，你应该注意到我们漏掉了一种特殊的箭头。<br>当然，同样地，小于等于操作符&lt;=也形似箭头，你可以在JS代码、隐藏的图片样式中找到更多类似的箭头，但是我们就不继续寻找了，你应该注意到我们漏掉了一种特殊的箭头。</p>
<blockquote>
<p><code>&lt;!--</code>    单行注释<br><code>--&gt;</code>    “趋向于”操作符<br> <code>&lt;=</code>   小于等于<br><code>=&gt;</code>       这又是什么？<br><code>=&gt;</code>   到底是什么？我们今天就来一探究竟。</p>
</blockquote>
<p>首先，我们谈论一些有关函数的事情。<br><br><br><strong>函数表达式无处不在</strong><br>JavaScript中有一个有趣的特性，无论何时，当你需要一个函数时，你都可以在想添加的地方输入这个函数。</p>
<p><code>举个例子</code>，假设你尝试告诉浏览器用户点击一个特定按钮后的行为，你会这样写：</p>
<pre><code>$(&quot;#confetti-btn&quot;).click(
</code></pre><p>jQuery的.click()方法接受一个参数：一个函数。没问题，你可以在这里输入一个函数：</p>
<pre><code>$(&quot;#confetti-btn&quot;).click(function (event) {
  playTrumpet();
  fireConfettiCannon();
});
</code></pre><p>对 于现在的我们来说，写出这样的代码相当自然，而回忆起在这种编程方式流行之前，这种写法相对陌生一些，许多语言中都没有这种特性。1958年，Lisp首 先支持函数表达式，也支持调用lambda函数，而C++，Python、C#以及Java在随后的多年中一直不支持这样的特性。</p>
<p>现在截然不同，所有的四种语言都已支持<code>lambda</code>函数，更新出现的语言普遍都支持内建的lambda函数。我们必须要感谢JavaScript和早期的JavaScript程序员，他们勇敢地构建了重度依赖lambda函数的库，让这种特性被广泛接受。</p>
<p>令人伤感的是，随后在所有我提及的语言中，只有JavaScript的lambda的语法最终变得冗长乏味。</p>
<pre><code>// 六种语言中的简单函数示例
function (a) { return a &gt; 0; } // JS
[](int a) { return a &gt; 0; }  // C++
(lambda (a) (&gt; a 0))  ;; Lisp
lambda a: a &gt; 0  # Python
a =&gt; a &gt; 0  // C#
a -&gt; a &gt; 0  // Java
</code></pre><p><br><br><strong><em>箭袋中的新羽</em></strong><br>ES6中引入了一种编写函数的新语法</p>
<pre><code>// ES5
var selected = allJobs.filter(function (job) {
  return job.isSelected();
});
// ES6
var selected = allJobs.filter(job =&gt; job.isSelected());
</code></pre><p>当你只需要一个只有一个参数的简单函数时，可以使用新标准中的箭头函数，它的语法非常简单：标识符=&gt;表达式。你无需输入function和return，一些小括号、大括号以及分号也可以省略。</p>
<p>（我个人对于这个特性非常感激，不再需要输入function这几个字符对我而言至关重要，因为我总是不可避免地错误写成functoin，然后我就不得不回过头改正它。）</p>
<p>如果要写一个接受多重参数（也可能没有参数，或者是不定参数、默认参数、参数解构）的函数，你需要用小括号包裹参数list。</p>
<pre><code>// ES5
var total = values.reduce(function (a, b) {
  return a + b;
}, 0);
// ES6
var total = values.reduce((a, b) =&gt; a + b, 0);
</code></pre><p>我认为这看起来酷毙了。</p>
<p>正如你使用类似Underscore.js和Immutable.js这样的库提供的函数工具，箭头函数运行起来同样美不可言。事实上，Immutable的文档中的示例全都由ES6写成，其中的许多特性已经用上了箭头函数。</p>
<p>那么不是非常函数化的情况又如何呢？除表达式外，箭头函数还可以包含一个块语句。回想一下我们之前的示例：</p>
<pre><code>// ES5
$(&quot;#confetti-btn&quot;).click(function (event) {
  playTrumpet();
  fireConfettiCannon();
});
</code></pre><p>这是它们在ES6中看起来的样子：</p>
<pre><code>// ES6
$(&quot;#confetti-btn&quot;).click(event =&gt; {
  playTrumpet();
  fireConfettiCannon();
});
</code></pre><p>这是一个微小的改进，对于使用了Promises的代码来说箭头函数的效果可以变得更加戏剧性，}).then(function (result) { 这样的一行代码可以堆积起来。</p>
<p>注意，使用了块语句的箭头函数不会自动返回值，你需要使用return语句将所需值返回。</p>
<p>小提示：当使用箭头函数创建普通对象时，你总是需要将对象包裹在小括号里。</p>
<pre><code>// 为与你玩耍的每一个小狗创建一个新的空对象
var chewToys = puppies.map(puppy =&gt; {});   // 这样写会报Bug！
var chewToys = puppies.map(puppy =&gt; ({})); //
</code></pre><p>用小括号包裹空对象就可以了。</p>
<p>不幸的是，一个空对象{}和一个空的块{}看起来完全一样。ES6中的规则是，紧随箭头的{被解析为块的开始，而不是对象的开始。因此，puppy =&gt; {}这段代码就被解析为没有任何行为并返回undefined的箭头函数。</p>
<p>更令人困惑的是，你的JavaScript引擎会将类似{key: value}的对象字面量解析为一个包含标记语句的块。幸运的是，{是唯一一个有歧义的字符，所以用小括号包裹对象字面量是唯一一个你需要牢记的小窍门。<br><br><br><br><br><strong>箭头函数与this</strong><br><br><br>既然要说箭头函数, 自然避不开this了<br>了解es5的人,应该知道, 在不同地方使用this,它的指向也有所不同, 但总归来讲, 实际上this总是指向最后调用它的对象.</p>
<p>举个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">var o = &#123;</span><br><span class="line">    a:10,</span><br><span class="line">    b:&#123;</span><br><span class="line">        a:12,</span><br><span class="line">        fn:function()&#123;</span><br><span class="line">            console.log(this.a); //undefined</span><br><span class="line">            console.log(this); //window        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">var j = o.b.fn;</span><br><span class="line">j();</span><br></pre></td></tr></table></figure>
<p>上面这个例子中，fn函数始终没有执行，直到执行j();而j()又是通过window来调用，所以最后输出的this是window.<br>总的来说, this的调用方式和指向有以下几种:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">函数调用方式和this指向:</span><br><span class="line">  （1）直接调用：函数内部this指向全局window</span><br><span class="line">  （2） 通过对象使用点来调用：函数内部this指向调用对象</span><br><span class="line">  （3） 触发事件调用函数：函数内部this指向调用触发事件的对象</span><br><span class="line">  （4） 以new的方式来调用：函数内部this指向本次函数执行时对应的一个匿名对象。</span><br><span class="line">  （5） 通过call的方法来间接调用方法：函数内部this指向call方法的第一个参数（自己指定this）。</span><br></pre></td></tr></table></figure>
<p>这篇文章的目的不是要解析this, 如果对this不清楚的童鞋,可以参考这篇文档: <a href="http://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank" rel="noopener">this 指向详细解析（箭头函数）</a>  </p>
<p>看到this在这么多调用方式下的指向都不同, 有没有被绕晕? 相信肯定也有很多童鞋跟我一样,踩过this的坑. 而箭头函数的存在, 就避免了这种指向问题,在箭头函数中, this总是指向词法作用域, 也就是外层的调用者.</p>
<p>看个例子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = function () &#123;</span><br><span class="line">            return new Date().getFullYear() - this.birth; // this指向window或undefined</span><br><span class="line">        &#125;;</span><br><span class="line">        return fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面这个例子中,fn()并没有得到我们预期的日期, 而是出错,因为在fn()函数中,this.birth并不是指向当前obj,而是指向函数的调用者window, 因此birth是undefined,</p>
<p>现在让我们用箭头函数来改造这个函数:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123;</span><br><span class="line">    birth: 1990,</span><br><span class="line">    getAge: function () &#123;</span><br><span class="line">        var b = this.birth; // 1990</span><br><span class="line">        var fn = () =&gt; new Date().getFullYear() - this.birth; // this指向obj对象</span><br><span class="line">        return fn();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.getAge(); // 27</span><br></pre></td></tr></table></figure>
<p>在箭头函数中, this指向的是外层调用者obj,因此最后拿到了birth这个参数.</p>
<p>另外,在箭头函数中,我们不再需要这种hack写法:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var that = this;</span><br></pre></td></tr></table></figure>
<p><strong>关于箭头函数的案例</strong><br>上面应该大致说明白了箭头函数吧?<br>那么现在,就来说说它的使用.<br><br><br><strong>改造开始</strong><br><br><br>首先，我们从一个例子开始，在 ES5 中，我们一般是这么书写的。</p>
<blockquote>
<p>var sum1 = function(num1, num2) { return num1 + num2; };</p>
</blockquote>
<p>那么，改造成箭头函数，它是什么样子呢？</p>
<blockquote>
<p>var sum2 = (num1, num2) =&gt; { return num1 + num2;};</p>
</blockquote>
<p>小括号内的参数列表和花括号内的代码被 =&gt; 分隔开了。这个就是箭头函数的魅力，箭头函数使得表达更加简洁，从而简化了我们的代码。</p>
<p>如果一个表达式的代码块, 只是 return 后面跟一个表达式，那么还可以进一步简化。</p>
<blockquote>
<p>var sum3 = (num1, num2) =&gt; num1 + num2;</p>
</blockquote>
<p>如果某个方法只含有一个参数。</p>
<blockquote>
<p>console.info(“=&gt; ES5 写法”);<br>var curf1 = function(v) {<br>return v;<br> };</p>
</blockquote>
<p>我们甚至可以省略小括号。</p>
<blockquote>
<p>console.info(“=&gt; ES6 写法”);<br>var curf2 = v =&gt; v;</p>
</blockquote>
<p>如果某个方法没有参数。</p>
<blockquote>
<p>console.info(“=&gt; ES5 写法”);<br>var f1 = function() {<br>return “梁桂钊”;<br>};</p>
</blockquote>
<p>我们仍可以提供一对空的小括号，如同不含参数的</p>
<blockquote>
<p>console.info(“=&gt; ES6 写法”);<br> var f2 = () =&gt; “梁桂钊”;</p>
</blockquote>
<p>补充一个例外，如果箭头函数直接返回一个对象，必须在对象外面加上括号。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES5 写法&quot;);</span><br><span class="line">var f3 = function() &#123;</span><br><span class="line">return &#123;</span><br><span class="line">real_name: &quot;梁桂钊&quot;,</span><br><span class="line">nick_name: &quot;LiangGzone&quot;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">console.log(f3());</span><br><span class="line"> </span><br><span class="line">console.info(&quot;=&gt; ES6 写法&quot;);</span><br><span class="line">var f4 = () =&gt; (&#123;real_name: &quot;梁桂钊&quot;,nick_name: &quot;LiangGzone&quot;&#125;);</span><br><span class="line">console.log(f4());</span><br></pre></td></tr></table></figure>
<p><br><br><strong>关于解构</strong><br>我们还可以使用到 ES6 解构赋值特性。ES5 写法，之前是这样的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var f5 = function(person) &#123;</span><br><span class="line">return person.first + &apos; &apos; + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>使用到 ES6 解构赋值特性后，就更加好理解了。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const f6 = (&#123; first, last &#125;) =&gt; first + &apos; &apos; + last;</span><br></pre></td></tr></table></figure>
<p><strong>关于回调函数</strong><br>我们经常使用回调函数，之前的常规的做法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES5 写法&quot;);</span><br><span class="line">var x1 = [1,2,3].map(function (x) &#123;</span><br><span class="line">return x * x;</span><br><span class="line">&#125;);</span><br><span class="line">console.info(x1);</span><br></pre></td></tr></table></figure>
<p>那么，现在我们可以进行改造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES6 写法&quot;);</span><br><span class="line">var x2 = [1,2,3].map(x =&gt; x * x);</span><br><span class="line">console.info(x2);</span><br></pre></td></tr></table></figure>
<p><strong>rest参数结合</strong></p>
<p>没有使用箭头函数，之前，我们的代码可能长这样子。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES5 写法&quot;);</span><br><span class="line">var x3 = function(...nums)&#123;</span><br><span class="line">return nums;</span><br><span class="line">&#125;</span><br><span class="line">console.info(x3(512, 1024));</span><br></pre></td></tr></table></figure>
<p>那么，现在我们可以进行改造。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">console.info(&quot;=&gt; ES6 写法&quot;);</span><br><span class="line">var x4 = (...nums) =&gt; nums;</span><br><span class="line">console.info(x4(512, 1024));</span><br></pre></td></tr></table></figure>
<p>那么, 我们什么时候会用到箭头函数呢?<br>ES6 的箭头函数在微软的新版本中有使用, 他们也在 Babel，Traceur，和 TypeScript 得到实现, 等等</p>
<p>以上就是我对箭头函数的一点点见解, 如果有不对的地方, 欢迎指正!</p>
<p>参考文档: (1) 深入浅出ES6（七）：箭头函数 Arrow Functions: <a href="https://blog.csdn.net/hqh642134542/article/details/78809951" target="_blank" rel="noopener">https://blog.csdn.net/hqh642134542/article/details/78809951</a><br>    (2).你看懂“箭头函数”了么？  <a href="https://www.cnblogs.com/libin-1/p/5995457.html" target="_blank" rel="noopener">https://www.cnblogs.com/libin-1/p/5995457.html</a><br>    (3).this 指向详细解析（箭头函数）: <a href="http://www.cnblogs.com/dongcanliang/p/7054176.html" target="_blank" rel="noopener">http://www.cnblogs.com/dongcanliang/p/7054176.html</a><br>    (4) 极客学院-箭头函数: <a href="http://wiki.jikexueyuan.com/project/es-six-deeply/arrow-functions.html" target="_blank" rel="noopener">http://wiki.jikexueyuan.com/project/es-six-deeply/arrow-functions.html</a><br>    (5) 廖雪峰-箭头函数: <a href="https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000" target="_blank" rel="noopener">https://www.liaoxuefeng.com/wiki/001434446689867b27157e896e74d51a89c25cc8b43bdb3000/001438565969057627e5435793645b7acaee3b6869d1374000</a><br>    (6) MDN-箭头函数: <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Functions/Arrow_functions</a><br>    (6) 阮一峰-箭头函数issue:  <a href="https://github.com/ruanyf/es6tutorial/issues/150" target="_blank" rel="noopener">https://github.com/ruanyf/es6tutorial/issues/150</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/09/10/关于React-setState的实现原理（三-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/10/关于React-setState的实现原理（三-md/" itemprop="url">关于React setState的实现原理（三).md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-10T10:30:51+08:00">
                2017-09-10
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react的概念理解/" itemprop="url" rel="index">
                    <span itemprop="name">react的概念理解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/10/关于React-setState的实现原理（三-md/" class="leancloud_visitors" data-flag-title="关于React setState的实现原理（三).md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><a href="https://yidongying.github.io/2017/09/08/%E5%85%B3%E4%BA%8EReact-setState%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%BA%8C-md/">上一篇文章中</a>提到事务即将结束时，会去调用FLUSH_BATCHED_UPDATES的flushBatchedUpdates方法执行批量更新，该方法会去遍历dirtyComponents，对每一项执行performUpdateIfNecessary方法，该方法代码如下：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">performUpdateIfNecessary: function (transaction) &#123;</span><br><span class="line">    if (this._pendingElement != null) &#123;</span><br><span class="line">      ReactReconciler.receiveComponent(this, this._pendingElement, transaction, this._context);</span><br><span class="line">    &#125; else if (this._pendingStateQueue !== null || this._pendingForceUpdate) &#123;</span><br><span class="line">      this.updateComponent(transaction, this._currentElement, this._currentElement, this._context, this._context);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      this._updateBatchNumber = null;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>在我们的setState更新中，其实只会用到第二个  <strong>this._pendingStateQueue !== null</strong>  的判断，即如果<strong>_pendingStateQueue</strong>中还存在未处理的<strong>state</strong>，那就会执行<strong>updateComponent</strong>完成更新。<br>那<strong>_pendingStateQueue</strong>是何时被处理的呢，继续看！</p>
<p>通过翻阅<strong>updateComponent</strong>方法，我们可以知道<strong>_pendingStateQueue</strong>是在该方法中由<strong>_processPendingState(nextProps, nextContext)</strong>方法做了一些处理，该方法传入两个参数，新的props属性和新的上下文环境，这个上下文环境可以先不用管。我们看看<strong>_processPendingState</strong>的具体实现：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">_processPendingState: function (props, context) &#123;</span><br><span class="line">    var inst = this._instance;    // _instance保存了Constructor的实例，即通过ReactClass创建的组件的实例</span><br><span class="line">    var queue = this._pendingStateQueue;</span><br><span class="line">    var replace = this._pendingReplaceState;</span><br><span class="line">    this._pendingReplaceState = false;</span><br><span class="line">    this._pendingStateQueue = null;</span><br><span class="line">    if (!queue) &#123;</span><br><span class="line">      return inst.state;</span><br><span class="line">    &#125;</span><br><span class="line">    if (replace &amp;&amp; queue.length === 1) &#123;</span><br><span class="line">      return queue[0];</span><br><span class="line">    &#125;</span><br><span class="line">    var nextState = _assign(&#123;&#125;, replace ? queue[0] : inst.state);</span><br><span class="line">    for (var i = replace ? 1 : 0; i &lt; queue.length; i++) &#123;</span><br><span class="line">      var partial = queue[i];</span><br><span class="line">      _assign(nextState, typeof partial === &apos;function&apos; ? partial.call(inst, nextState, props, context) : partial);</span><br><span class="line">    &#125;</span><br><span class="line">    return nextState;</span><br><span class="line">  &#125;，</span><br></pre></td></tr></table></figure>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;什么replace啊什么的都可以暂时不用看，主要先看for循环内部做的事情，replace我们暂时认为是false。<br>for循环遍历了<strong>_pendingStateQueue</strong>中所有保存的状态，对于每一个状态进行处理，处理时首先判断保存的是function还是object。若是function，就在inst的上下文中执行该匿名函数，该函数返回一个代表新state的object，然后执行assign将其与原有的state合并；若是object，则直接与state合并。<br><br><br>注意，传入setState的第一个参数如果是function类型，我们可以看到，其第一个参数nextState即表示更新之前的状态；第二个参数props代表更新之后的props，第三个context代表新的上下文环境。之后返回合并后的state。<br><br><br>这里还需要注意一点，这一点很关键，代码中出现了<strong>this._pendingStateQueue = null</strong>这么一段，这也就意味着<strong>dirtyComponents</strong>进入下一次循环时，执行<strong>performUpdateIfNecessary</strong>不会再去更新组件，这就实现了批量更新，即只做一次更新操作，React在更新组件时就是用这种方式做了优化。</p>
<p>&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;好了，回来看我们的案例，当我们传入函数作为setState的第一个参数时，我们用该函数提供给我们的state参数来访问组件的state。该state在代码中就对应nextState这个值，这个值在每一次for循环执行时都会对其进行合并，因此第二次执行setState，我们在函数中访问的state就是第一次执行setState后已经合并过的值，所以会打印出2。然而直接通过this.state.count来访问，因为在执行对_pendingStateQueue的for循环时，组件的update还未执行完，this.state还未被赋予新的值，其实了解一下updateComponent会发现，this.state的更新会在_processPendingState执行完执行。所以两次setState取到的都是this.state.count最初的值0，这就解释了之前的现象。其实，这也是React为了解决这种前后state依赖但是state又没及时更新的一种方案，因此在使用时大家要根据实际情况来判断该用哪种方式传参。</p>
<p>接下来我们再来看看setState的第二个参数，回调函数，它是在什么时候执行的。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">    constructor(props) &#123;</span><br><span class="line">        super(props);</span><br><span class="line">        this.state = &#123;</span><br><span class="line">            count: 0</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidMount() &#123;</span><br><span class="line">        let me = this;</span><br><span class="line">        setTimeout(function() &#123;</span><br><span class="line">            me.setState(&#123;count: me.state.count + 1&#125;, function() &#123;</span><br><span class="line">                console.log(&apos;did callback&apos;);</span><br><span class="line">            &#125;);</span><br><span class="line">            console.log(&apos;hello&apos;);</span><br><span class="line">        &#125;, 0);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    componentDidUpdate() &#123;</span><br><span class="line">        console.log(&apos;did update&apos;);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line">        return &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这个案例控制台打印顺序是怎样的呢？<br>不卖关子了，答案是did update，did callback，hello。这里是在一个setTimeout中执行了setState，因此其处于一个单独的事务之中，所以hello最后打印容易理解。然后我们来看看setState执行更新时做了些啥。前面我们知道在执行完组件装载即调用了componentDidMount之后，事务开始执行一系列close方法，这其中包括调用FLUSH_BATCHED_UPDATES中的flushBatchedUpdates，我们来看看这段代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var flushBatchedUpdates = function () &#123;</span><br><span class="line">  // ReactUpdatesFlushTransaction&apos;s wrappers will clear the dirtyComponents</span><br><span class="line">  // array and perform any updates enqueued by mount-ready handlers (i.e.,</span><br><span class="line">  // componentDidUpdate) but we need to check here too in order to catch</span><br><span class="line">  // updates enqueued by setState callbacks and asap calls.</span><br><span class="line">  while (dirtyComponents.length || asapEnqueued) &#123;</span><br><span class="line">    if (dirtyComponents.length) &#123;</span><br><span class="line">      var transaction = ReactUpdatesFlushTransaction.getPooled();</span><br><span class="line">      transaction.perform(runBatchedUpdates, null, transaction);    // 处理批量更新</span><br><span class="line">      ReactUpdatesFlushTransaction.release(transaction);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    if (asapEnqueued) &#123;</span><br><span class="line">      asapEnqueued = false;</span><br><span class="line">      var queue = asapCallbackQueue;</span><br><span class="line">      asapCallbackQueue = CallbackQueue.getPooled();</span><br><span class="line">      queue.notifyAll();    // 处理callback</span><br><span class="line">      CallbackQueue.release(queue);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>可以看我做了中文标注的两个地方，这个方法其实主要就是处理了组件的更新和callback的调用。组件的更新发生在runBatchedUpdates这个方法中，下面的queue.notifyAll内部其实就是从队列中去除callback调用，因此应该是先执行完更新，调用componentDidUpdate方法之后，再去执行callback，就有了我们上面的结果。<br><br><br><strong>总结</strong><br>React在组件更新方面做了很多优化，这其中就包括了上述的批量更新。在componentDidMount中执行了N个setState，如果执行N次更新是件很傻的事情。React利用其独特的事务实现，做了这些优化。正是因为这些优化，才造成了上面见到的怪现象。还有一点，再使用this.state时一定要注意组件的生命周期，很多时候在获取state的时候，组件更新还未完成，this.state还未改变，这是很容易造成bug的一个地方，要避免这个问题，需要对组件生命周期有一定的了解。</p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/09/08/关于React-setState的实现原理（二-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/08/关于React-setState的实现原理（二-md/" itemprop="url">关于React setState的实现原理（二).md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-08T09:57:48+08:00">
                2017-09-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react的概念理解/" itemprop="url" rel="index">
                    <span itemprop="name">react的概念理解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/08/关于React-setState的实现原理（二-md/" class="leancloud_visitors" data-flag-title="关于React setState的实现原理（二).md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>上一篇文章中,写到了关于Batch Update的实现,有不懂的童鞋可以回头看看 <a href="https://yidongying.github.io/2017/09/05/%E5%85%B3%E4%BA%8EReact-setState%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%80-md/">上一篇文章</a><br><strong>React中的Transaction</strong><br>大家学过sql server的都知道我们可以批量处理sql语句，原理其实都是基于上一篇我们说的Datch Update机制。当所有的操作均执行成功，才会执行修改操作；若有一个操作失败，则执行rollback（回滚）。</p>
<p>在React中，我们介绍过事件会在函数前后执行自己的逻辑，具体就是调用perform方法进入一个事件，这个方法会传入一个method参数。执行perform时先执行initializeAll方法按照一定顺序执行一系列的initialize操作，然后执行传入的method，method执行完后，就执行closeAll方法按照一定顺序执行一系列的close操作。注意一种事件不能同时开启，否则会抛出异常。给一个例子是实现事件：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">var Transaction = require(&apos;./Transaction&apos;);</span><br><span class="line"></span><br><span class="line">// 我们自己定义的 Transaction</span><br><span class="line">var MyTransaction = function() &#123;</span><br><span class="line">  // do sth.</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(MyTransaction.prototype, Transaction.Mixin, &#123;</span><br><span class="line">  getTransactionWrappers: function() &#123;</span><br><span class="line">    return [&#123;</span><br><span class="line">      initialize: function() &#123;</span><br><span class="line">        console.log(&apos;before method perform&apos;);</span><br><span class="line">      &#125;,</span><br><span class="line">      close: function() &#123;</span><br><span class="line">        console.log(&apos;after method perform&apos;);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;];</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">var transaction = new MyTransaction();</span><br><span class="line">var testMethod = function() &#123;</span><br><span class="line">  console.log(&apos;test&apos;);</span><br><span class="line">&#125;</span><br><span class="line">transaction.perform(testMethod);</span><br><span class="line"></span><br><span class="line">// before method perform</span><br><span class="line">// test</span><br><span class="line">// after method perform</span><br></pre></td></tr></table></figure>
<p>具体到实现上，React 中的 Transaction 提供了一个 Mixin 方便其它模块实现自己需要的事务。而要使用 Transaction 的模块，除了需要把 Transaction 的 Mixin 混入自己的事务实现中外，还需要额外实现一个抽象的 getTransactionWrappers 接口。这个接口是 Transaction 用来获取所有需要封装的前置方法（initialize）和收尾方法（close）的，因此它需要返回一个数组的对象，每个对象分别有 key 为 initialize 和 close 的方法。</p>
<p>当然在实际代码中 React 还做了异常处理等工作，这里不详细展开。有兴趣的同学可以参考源码中 Transaction 实现。</p>
<p>组件调用ReactDOM.render()之后，会执行一个_renderNewRootComponent的方法，大概是该方法执行了一个ReactUpdates.batchedUpdates()。 那么batchedUpdates是什么呢？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">var transaction = new ReactDefaultBatchingStrategyTransaction();</span><br><span class="line"></span><br><span class="line">var ReactDefaultBatchingStrategy = &#123;</span><br><span class="line">  isBatchingUpdates: false,</span><br><span class="line"></span><br><span class="line">  /**</span><br><span class="line">   * Call the provided function in a context within which calls to `setState`</span><br><span class="line">   * and friends are batched such that components aren&apos;t updated unnecessarily.</span><br><span class="line">   */</span><br><span class="line">  batchedUpdates: function (callback, a, b, c, d, e) &#123;</span><br><span class="line">    var alreadyBatchingUpdates = ReactDefaultBatchingStrategy.isBatchingUpdates;</span><br><span class="line"></span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = true;</span><br><span class="line"></span><br><span class="line">    // The code is written this way to avoid extra allocations</span><br><span class="line">    if (alreadyBatchingUpdates) &#123;</span><br><span class="line">      return callback(a, b, c, d, e);</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      return transaction.perform(callback, null, a, b, c, d, e);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>从代码中可以看出，这个batchedUpdate是第一次调用alreadyBatchingUpdates是false（储存起来了），回去执行transaction.perform(method)（前边说过perform执行会进入一个时间），这样就进入第一个事务，</p>
<p>这个事务是啥我们现在不用管，我们只需要知道这个transaction是ReactDefaultBatchingStrategyTransaction的实例，它代表了其中一类事务的执行。然后会执行method方法，就会进行组件的首次装载。完成后会调用</p>
<p>componentDidMount(注意，此时还是在执行method方法，事务还没结束，事务只有在执行完method后执行一系列close才会结束),在该方法中，我们调用了setState，出现了一系列奇怪的现象。因此，我们再来看看</p>
<p>setState方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">ReactComponent.prototype.setState = function (partialState, callback) &#123;</span><br><span class="line">  !(typeof partialState === &apos;object&apos; || typeof partialState === &apos;function&apos; || partialState == null) ? &quot;development&quot; !== &apos;production&apos; ? invariant(false, &apos;setState(...): takes an object of state variables to update or a function which returns an object of state variables.&apos;) : _prodInvariant(&apos;85&apos;) : void 0;</span><br><span class="line">  this.updater.enqueueSetState(this, partialState);</span><br><span class="line">  if (callback) &#123;</span><br><span class="line">    this.updater.enqueueCallback(this, callback, &apos;setState&apos;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>setState在调用时做了两件事，第一，调用enqueueSetState。该方法将我们传入的partialState添加到一个叫做_pendingStateQueue的队列中去存起来，然后执行一个enqueueUpdate方法。<br><br><br>第二，如果存在callback就调用enqueueCallback将其存入一个_pendingCallbacks队列中存起来。然后我们来看enqueueUpdate方法。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line"></span><br><span class="line">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class="line">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class="line">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class="line">  // function, like setState, forceUpdate, etc.; creation and</span><br><span class="line">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class="line"></span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123;</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  if (component._updateBatchNumber == null) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>上面的代码中，这个<strong>batchingStrategy</strong>就是上面的<strong>ReactDefaultBatchingStrategy</strong>，只是它通过<strong>inject</strong>的形式对其进行赋值，比较隐蔽。因此，我们当前的setState已经处于了这一类事务之中，isBatchingUpdates已经被置为true，所以将会把它添加到<strong>dirtyComponents</strong>中，在某一时刻做批量更新。<br><br><br>因此在前两个setState中，并没有做任何状态更新，以及组件更新的事，而仅仅是将新的state和该组件存在了队列之中，因此两次都会打印出0，我们之前的第一个问题就解决了，还有一个问题，我们接着往下走。<br><br><br>在setTimeout中执行的setState打印出了2和3，有了前面的铺垫，我们大概就能得出结论，这应该就是因为这两次setState分别执行了一次完整的事务，导致state被直接更新而造成的结果。那么问题来了，为什么setTimeout中的setState会分别执行两次不同的事务？之前执行ReactDOM.render开启的事务在什么时候结束了？我们来看下列代码。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">var RESET_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: function () &#123;</span><br><span class="line">    ReactDefaultBatchingStrategy.isBatchingUpdates = false;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var FLUSH_BATCHED_UPDATES = &#123;</span><br><span class="line">  initialize: emptyFunction,</span><br><span class="line">  close: ReactUpdates.flushBatchedUpdates.bind(ReactUpdates)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">var TRANSACTION_WRAPPERS = [FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES];</span><br><span class="line"></span><br><span class="line">function ReactDefaultBatchingStrategyTransaction() &#123;</span><br><span class="line">  this.reinitializeTransaction();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">_assign(ReactDefaultBatchingStrategyTransaction.prototype, Transaction, &#123;</span><br><span class="line">  getTransactionWrappers: function () &#123;</span><br><span class="line">    return TRANSACTION_WRAPPERS;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>这段代码也是写在<strong>ReactDefaultBatchingStrategy</strong>这个对象中的。我们之前提到这个事务中<strong>transaction</strong>是<strong>ReactDefaultBatchingStrategyTransaction</strong>的实例，这段代码其实就是给该事务添加了两个在事务结束时会被调用的close方法。即在perform中的method执行完毕后，会按照这里数组的顺序<strong>[FLUSH_BATCHED_UPDATES, RESET_BATCHED_UPDATES]</strong>依次调用其close方法。<br><br><br><strong>FLUSH_BATCHED_UPDATES</strong>是执行批量更新操作。<strong>RESET_BATCHED_UPDATES</strong>我们可以看到将<strong>isBatchingUpdates</strong>变回false，即意味着事务结束。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">function enqueueUpdate(component) &#123;</span><br><span class="line">  ensureInjected();</span><br><span class="line">  // Various parts of our code (such as ReactCompositeComponent&apos;s</span><br><span class="line">  // _renderValidatedComponent) assume that calls to render aren&apos;t nested;</span><br><span class="line">  // verify that that&apos;s the case. (This is called by each top-level update</span><br><span class="line">  // function, like setState, forceUpdate, etc.; creation and</span><br><span class="line">  // destruction of top-level components is guarded in ReactMount.)</span><br><span class="line">  if (!batchingStrategy.isBatchingUpdates) &#123; //上一个事件结束执行过isBatchedUpdates=false,所以进入if中</span><br><span class="line">    batchingStrategy.batchedUpdates(enqueueUpdate, component);</span><br><span class="line">    return;</span><br><span class="line">  &#125;</span><br><span class="line">  dirtyComponents.push(component);</span><br><span class="line">  if (component._updateBatchNumber == null) &#123;</span><br><span class="line">    component._updateBatchNumber = updateBatchNumber + 1;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>接下来再调用setState时（在setTimeout中，前文说过一步操作不会在主线程，我理解是在主线程结束才会执行，此时的主线程事件已经结束），enqueueUpdate不会再将其添加到dirtyComponents中，而是执行batchingStrategy.batchedUpdates(enqueueUpdate, component)开启一个新事务。<br><br><br>但是需要注意，这里传入的参数是enqueueUpdate，即perform中执行的method为enqueueUpdate，而再次调用该enqueueUpdate方法会去执行dirtyComponents那一步。这就可以理解为，处于单独事务的setState也是通过将组件添加到dirtyComponents来完成更新的，只不过这里是在enqueueUpdate执行完毕后立即执行相应的close方法完成更新，而前面两个setState需在整个组件装载完成之后，即在componentDidMount执行完毕后才会去调用close完成更新。总结一下4个setState执行的过程就是：先执行两次console.log，然后执行批量更新，再执行setState直接更新，执行console.log，最后再执行setState直接更新，再执行console.log，所以就会得出0,0,2,3。<br><br><br>到现在上面的问题已经解决，但是又出现一个新问题：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let me = this;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;   //页面中将打印出1</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let me = this;</span><br><span class="line">    me.setState(function(state, props) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">    me.setState(function(state, props) &#123;</span><br><span class="line">      return &#123;</span><br><span class="line">        count: state.count + 1</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;   //页面中将打印出2</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><br><br>这两种写法，一个是在setState中传入了object，一个是传入了function，却得到了两种不同的结果，这是什么原因造成的，这就需要我们去深入了解一下进行批量更行时都做了些什么。<br>关于这个部分, 可以看看我的<a href="https://yidongying.github.io/2018/07/05/%E5%85%B3%E4%BA%8EReact-setState%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86%EF%BC%88%E4%B8%89-md/">下一篇文章</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/09/05/关于React-setState的实现原理（一-md/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/09/05/关于React-setState的实现原理（一-md/" itemprop="url">关于React setState的实现原理（一).md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-09-05T09:57:48+08:00">
                2017-09-05
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react的概念理解/" itemprop="url" rel="index">
                    <span itemprop="name">react的概念理解</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/09/05/关于React-setState的实现原理（一-md/" class="leancloud_visitors" data-flag-title="关于React setState的实现原理（一).md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>首先在学习react的时候就对setSate的实现有比较浓厚的兴趣，那么对于下边的代码，可以快速回答吗？</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">class Root extends React.Component &#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    super(props);</span><br><span class="line">    this.state = &#123;</span><br><span class="line">      count: 0</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    let me = this;</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(me.state.count);    // 打印</span><br><span class="line">    me.setState(&#123;</span><br><span class="line">      count: me.state.count + 1</span><br><span class="line">    &#125;);</span><br><span class="line">    console.log(me.state.count);    // 打印</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">     me.setState(&#123;</span><br><span class="line">       count: me.state.count + 1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(me.state.count);   // 打印</span><br><span class="line">    &#125;, 0);</span><br><span class="line">    setTimeout(function()&#123;</span><br><span class="line">     me.setState(&#123;</span><br><span class="line">       count: me.state.count + 1</span><br><span class="line">     &#125;);</span><br><span class="line">     console.log(me.state.count);   // 打印</span><br><span class="line">    &#125;, 0);</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    return (</span><br><span class="line">      &lt;h1&gt;&#123;this.state.count&#125;&lt;/h1&gt;</span><br><span class="line">    )</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>这段代码大家可能在很多地方看见过，结果是让你匪夷所思的0，0，2，3。 大部分人相信都不知道其中的原因，首先肯定会问：</p>
<p>为什么前两次为零，而加上setTimeout就可以打印出来？<br>为什么setTimeout打印出不同的结果？<br>那么请你接下来向下看，我首先说一下Batch Updata（批量更新）。如下图：<br><img src="https://img-blog.csdn.net/2018070510045176?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p><strong>什么是Batch Update ?</strong><br>在一些MV*框架中，就是将一段时间内对model的修改批量更新到view的机制。比如那前端比较火的React、vue为例。</p>
<p>在React中，我们在componentDidMount生命周期连续调用SetState：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  this.setState(&#123; foo: 1 &#125;)</span><br><span class="line">  this.setState(&#123; foo: 2 &#125;)</span><br><span class="line">  this.setState(&#123; foo: 3 &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在没有Batch Update的情况下，上面的操作会导致三次组件渲染，但是使用Batch Update机制下时间上只运行了一次渲染。componentDidMount中三次对model的操作被优化为一次view更新，</p>
<p>不必要的Vitual Dom计算被忽略，从而提高了框架的效率。</p>
<p><strong>Batch Update的实现</strong><br>我们想到的可能就是数据结构中的栈和队列，比较一下还是使用一个queue来保存update，并在合适的时机对这个queue进行flush操作。那么现在有两个问题：</p>
<p><strong>什么时候创建这个queue</strong><br><strong>什么时候对这个queue进行flush</strong><br>那么我们要对Reac和Vue的源码进行分析，首先React：React中的Batch Update是通过Transaction（事务）来实现的。在React源码关于Transaction的部分可以用一幅画解释：</p>
<p><img src="https://img-blog.csdn.net/20180705100619182?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p> Transaction对一个函数进行包装，让React有机会在一个函数执行前和执行后运行特定的逻辑，从而完成对整个Batch Update流程的控制。</p>
<p>简单的说就是在要执行的函数中用事务包裹起来，在函数执行前加入initialize阶段，函数执行，最后执行close阶段。那么Batch Update中</p>
<p>在事件initialize阶段，一个update queue被创建。在事件中调用setState方法时，状态不会被立即调用，而是被push进Update queue中。</p>
<p>函数执行结束调用事件的close阶段，Update queue会被flush，这事新的状态才会被应用到组件上并开始后续的Virtual DOM更新，biff算法来对</p>
<p>model更新。</p>
<p>对比于React，Vue实现Batch update就简单多了：直接借助JS中的Event Loop。（参考阮老师的<a href="http://www.ruanyifeng.com/blog/2013/10/event_loop.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2013/10/event_loop.html</a>）</p>
<p>Vue中的核心代码就仅仅20多行，如下:</p>
<p>// <a href="https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js#L122-L148" target="_blank" rel="noopener">https://github.com/vuejs/vue/blob/dev/src/core/observer/scheduler.js#L122-L148</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * Push a watcher into the watcher queue.</span><br><span class="line"> * Jobs with duplicate IDs will be skipped unless it&apos;s</span><br><span class="line"> * pushed when the queue is being flushed.</span><br><span class="line"> */</span><br><span class="line">export function queueWatcher (watcher: Watcher) &#123;</span><br><span class="line">  const id = watcher.id</span><br><span class="line">  if (has[id] == null) &#123;</span><br><span class="line">    has[id] = true</span><br><span class="line">    if (!flushing) &#123;</span><br><span class="line">      queue.push(watcher)</span><br><span class="line">    &#125; else &#123;</span><br><span class="line">      // if already flushing, splice the watcher based on its id</span><br><span class="line">      // if already past its id, it will be run next immediately.</span><br><span class="line">      let i = queue.length - 1</span><br><span class="line">      while (i &gt; index &amp;&amp; queue[i].id &gt; watcher.id) &#123;</span><br><span class="line">        i--</span><br><span class="line">      &#125;</span><br><span class="line">      queue.splice(i + 1, 0, watcher)</span><br><span class="line">    &#125;</span><br><span class="line">    // queue the flush</span><br><span class="line">    if (!waiting) &#123;</span><br><span class="line">      waiting = true</span><br><span class="line">      nextTick(flushSchedulerQueue)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>当model被修改时，对应的watcher会被推入Update queue， 与此同时还会在异步队列中添加一个task用于flush当前的Update queue。</p>
<p>这样一来，当前的task中的其他watcher会被推进同一个Update queue中。当前task执行结束后，异步队列下一个task执行，update queue</p>
<p>会被 flush，并进行后续的更新操作。</p>
<p>为了让 flush 动作能在当前 Task 结束后尽可能早的开始，Vue 会优先尝试将任务 micro-task 队列，具体来说，在浏览器环境中 Vue 会优</p>
<p>先尝试使用 MutationObserver API 或 Promise，如果两者都不可用，则 fallback 到 setTimeout。</p>
<p>对比两个框架可以发现 React 基于 Transition 实现的 Batch Query 是一个不依赖语言特性的通用模式，因此有更稳定可控的表现，但缺点</p>
<p>是无法完全覆盖所有情况，例如对于如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount () &#123;</span><br><span class="line">  setTimeout(_ =&gt; &#123;</span><br><span class="line">    this.setState(&#123; foo: 1 &#125;)</span><br><span class="line">    this.setState(&#123; foo: 2 &#125;)</span><br><span class="line">    this.setState(&#123; foo: 3 &#125;)</span><br><span class="line">  &#125;, 0)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>由于 setTimeout 的回调函数「不受 React 控制」，其中的 setState 就无法得到优化，最终会导致 render 函数执行三次。</p>
<p>而 Vue 的实现则对语言特性乃至运行环境有很强的依赖，但可以更好的覆盖各种情况：只要是在同一个 task 中的修改都可以进行 Batch Update 优化。</p>
<p><br><br><br><br><strong>总结一下：</strong><br><br><br> React 在这里的更新和事务机制使用比较通用的处理方式。<br><br><br>比如默认第一次应用初始化的时候是一次事务的进行，在用户交互的时候是一次新的事务开始，会在同一次同步事务中标记 batchUpdate=true，这样的做法是不破坏使用者的代码。<br>然后如果是 Ajax，setTimeout 等要离开主线程进行异步操作的时候会脱离当前 UI 的事务，这时候再进入此次处理的时候 batchUpdate=false，所以才会 setState 几次就 render 几次。<br><br><br>Vue 的策略虽然在机制上雷同，但是从根本上来讲是一种延迟的批量更新机制。<br><br><br>Angular 在这里也处理得很巧妙，利用 zone.js 对 task 进行拦截，对 JS 现有场景进行 AOP，这样就成功的桥接了代码。<br><br><br>React 的事务是纯粹的 IO 模型的适配。<br><br><br> 那么Batch Update介绍到这里 ，在下一篇我们将参考React源码来分析setState的实现过程。<br> <br><br> <strong>参考文档:</strong><br>     饿了么前端团队对于batch Update的理解: <a href="https://zhuanlan.zhihu.com/p/28532725" target="_blank" rel="noopener">https://zhuanlan.zhihu.com/p/28532725</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/08/23/react的状态提升/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/23/react的状态提升/" itemprop="url">react的状态提升.md</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-23T11:02:39+08:00">
                2017-08-23
              </time>
            

            

            
          </span>

          

          
            
          

          
          
             <span id="/2017/08/23/react的状态提升/" class="leancloud_visitors" data-flag-title="react的状态提升.md">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1.概念理解</strong><br>在react中是单向数据流的设计, 即 只有父组件可以传递数据给子组件,而没有子组件传递数据给父组件的概念. 以正确的技术说明，是 拥有者组件 可以设置 被拥有者组件 中的资料，也就是主人与仆人的关系。</p>
<p>那么子组件要传递数据给父组件该如何沟通呢?</p>
<p>换句话说就是, react 如何将子组件的值暴露让父组件获取到?</p>
<p>可以采用一种迂回的方法, 在父组件中设置一个方法(函数), 将其通过props传递给子组件, 然后在子组件中更新state的状态,并调用父组件中传过来的方法, 将state数据作为参数传递给父组件. 这样, 改变父组件的状态，从而改变受父组件控制的所有子组件的状态. 这就是状态提升的概念.   用官方的原话就是:    ‘共享 state(状态) 是通过将其移动到需要它的组件的最接近的共同祖先组件来实现的。 这被称为“状态提升(Lifting State Up)’。</p>
<p><strong>官方参考网址: <a href="http://www.css88.com/react/docs/lifting-state-up.html" target="_blank" rel="noopener">http://www.css88.com/react/docs/lifting-state-up.html</a></strong></p>
<p><strong>2.举例说明</strong><br><br><br>下面举个例子说明:</p>
<p>App.js文件   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line">import  React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">import Item from &apos;./Item&apos;</span><br><span class="line"></span><br><span class="line">export default class App extends Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">        super(props)</span><br><span class="line"></span><br><span class="line">        this.state = &#123;</span><br><span class="line"></span><br><span class="line">            options: [</span><br><span class="line"></span><br><span class="line">                &#123;name:&apos;（1）免费行李&apos;, value: 1 &#125;,</span><br><span class="line"></span><br><span class="line">                &#123;name:&apos;2&apos;, value: 2 &#125;,</span><br><span class="line"></span><br><span class="line">                &#123;name:&apos;3&apos;, value: 3 &#125; ],</span><br><span class="line"></span><br><span class="line">            price: 0</span><br><span class="line"></span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">   &#125;</span><br><span class="line"></span><br><span class="line">    changePrice = (value) =&gt; &#123;</span><br><span class="line"></span><br><span class="line">        let price = 800</span><br><span class="line"></span><br><span class="line">        if(value === 1)  price = 0</span><br><span class="line"></span><br><span class="line">        else</span><br><span class="line"></span><br><span class="line">        price *= value - 1</span><br><span class="line"></span><br><span class="line">        this.setState(&#123;price: price&#125;) &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">    return (</span><br><span class="line"></span><br><span class="line">        &#123;this.state.price&#125;</span><br><span class="line"></span><br><span class="line">)  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Item.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;</span><br><span class="line"></span><br><span class="line">export default class Item extends Component &#123;</span><br><span class="line"></span><br><span class="line">    constructor(props) &#123;</span><br><span class="line"></span><br><span class="line">        super(props)</span><br><span class="line"></span><br><span class="line">        this.handleChange = this.handleChange.bind(this)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    handleChange(e)&#123;</span><br><span class="line"></span><br><span class="line">    this.props.changePrice(e.target.value)</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    render() &#123;</span><br><span class="line"></span><br><span class="line">        var options = []</span><br><span class="line"></span><br><span class="line">        var optionArray = this.props.optionArray</span><br><span class="line"></span><br><span class="line">        options = optionArray.map(function(item, index)&#123;</span><br><span class="line"></span><br><span class="line">            return ( &#123;item.name&#125; )</span><br><span class="line"></span><br><span class="line">        &#125;)</span><br><span class="line"></span><br><span class="line">        return ( &#123;options&#125; )</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明:</p>
<p> <strong>2.1. 先绑定(bind)住render有用到的方法</strong></p>
<p>在父组件与子组件各有用到一个自己的方法changePrice，并在render中作赋值，在React中需要bind过才会把this对住，因为在render的return语句中使用，它在重渲染(re-render)时会再次建立新的方法(函数)内容值，这样会有效能上的影响，所以要先作绑定的事，然后再render的return里面用。关于bind(this)的一些理解,在我的另一篇文章,可以参考:<a href="https://www.jianshu.com/p/f7f2636d16a9" target="_blank" rel="noopener">https://www.jianshu.com/p/f7f2636d16a9</a></p>
<p>先绑定要在类的contructor里作，像下面这样，我这写一个父组件而已，子组件一样:</p>
<p>constructor(props) {super(props)this.state = {price:0}//先bind类中方法this.changePrice =this.changePrice.bind(this)  }</p>
<p>之后在render的return要改成这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return(</span><br><span class="line">	&lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.2 校正state(状态)里的资料，以及提升到父组件去</strong></p>
<p>在子组件中的state(状态)中的资料是不是有那么必要放在子组件中，如果你还有第二个子组件、第三、第四…，它们都要用例如这里的选中资料，你放在这个子组件是违反了上面说的应用领域全局资料思维的。</p>
<p>先看一下子组件目前的state，是长这个样子:</p>
<pre><code>this.state = {names: [&apos;（1）免费行李&apos;,&apos;2&apos;,&apos;3&apos;],values: [&apos;1&apos;,&apos;2&apos;,&apos;3&apos;],selectName:&apos;&apos;,prices:&apos;0&apos;}
</code></pre><p>这里要先校正一下，names与values是代表选项中的名与值，它们是有关联的，所以应该是这样的下面结构才是好些的，value如果是要用来代表数字，就用数字就行不需要用字串:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">options: [  &#123;name:&apos;（1）免费行李&apos;,value:1&#125;,  &#123;name:&apos;2&apos;,value:2&#125;,  &#123;name:&apos;3&apos;,value:3&#125;]</span><br></pre></td></tr></table></figure>
<p>选中了哪个选项这个状态资料，还是要先放在子组件中，因为子组件中有选项盒，与触发的更动方法，但选项的资料可以移到上层的父组件中:</p>
<p>这是上层App.js中的状态:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">this.state = &#123;</span><br><span class="line">	options: [</span><br><span class="line">		&#123;name:&apos;（1）免费行李&apos;,value:1&#125;,</span><br><span class="line">		&#123;name:&apos;2&apos;,value:2&#125;,  </span><br><span class="line">		&#123;name:&apos;3&apos;,value:3&#125;],</span><br><span class="line">	price:0</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>父组件也改用把state里面的选项值，用props值给子组件，所以在render里语句改成下面这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">render() &#123;</span><br><span class="line">  return(</span><br><span class="line">    &lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">  );  </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>子组件中这时可以用this.props.optionArray接到传入的选项值，所以在render方法中，改用这个来代替之前的this.state.names与this.state.values，简单改写如下:</p>
<p>varoptions = []varprices =this.state.pricesvaroptionArray =this.props.optionArrayfor(vari =0; i&lt; optionArray.length; i++) {      options.push({optionArray[i].name})  }</p>
<p>注: 这里不用for…in语句而用for语句，是因为for…in语句是个不建议用在数组资料的语法，它并不会保证取到数组成员里的顺序。for…in只会用在对象的寻遍中。</p>
<p>更精简的写法是用Array.map，如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var options = []</span><br><span class="line">var prices =this.state.prices</span><br><span class="line">var optionArray =this.props.optionArray</span><br><span class="line">options = optionArray.map(function(item, index)&#123;return(&#123;item.name&#125;)&#125;)</span><br></pre></td></tr></table></figure>
<p>接着，如果依选项选中然后计算价格这件事，规划中应该是整个应用来作的，例如有可能还有其他的组件中也有其他的选项，最后统一要来算价格，所以计算价格这件事，也应该放到父组件去，所以如同上面的改写一样，把子组件的prices状态与相关计算的代码，都提到父组件，这个子组件纯用来当选项盒用而已。子组件此时连state都可以不用有。</p>
<p>因为整个改写过的代码会多些，所以我把父组件与子组件中的代码整个贴上。</p>
<p>父组件App.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125; from &apos;react&apos;;</span><br><span class="line">import Item from&apos;./Item&apos;</span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">constructor(props) &#123;</span><br><span class="line">	super(props)</span><br><span class="line">	this.state = &#123;options: [ &#123;name:&apos;（1）免费行李&apos;,value:1&#125;,        &#123;name:&apos;2&apos;,value:2&#125;,        &#123;name:&apos;3&apos;,value:3&#125;   ],price:0&#125;</span><br><span class="line">	this.changePrice =this.changePrice.bind(this)  </span><br><span class="line">&#125;  </span><br><span class="line">changePrice(value)&#123;</span><br><span class="line">	var price =800;</span><br><span class="line">	if(value ===1) </span><br><span class="line">	price =0 </span><br><span class="line">	else</span><br><span class="line">	price = (value -1) * price</span><br><span class="line">	this.setState(&#123;price: price&#125;)  &#125;  </span><br><span class="line">render() &#123;</span><br><span class="line">	return(</span><br><span class="line">	&lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">	)  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>子组件Item.js:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125;from&apos;react&apos;</span><br><span class="line">export default class Item extends Component&#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props)</span><br><span class="line">	&#125;  </span><br><span class="line">	handleChange(e)&#123;</span><br><span class="line">		this.props.changePrice(e.target.value)  </span><br><span class="line">	&#125;  </span><br><span class="line">	render() &#123;</span><br><span class="line">	var options = []</span><br><span class="line">	var optionArray =this.props.optionArray    </span><br><span class="line">	options = optionArray.map(function(item, index)&#123;return(&#123;item.name&#125;)    &#125;)return(</span><br><span class="line"></span><br><span class="line">&lt;div&gt;&#123;options&#125;&lt;/div&gt;</span><br><span class="line"></span><br><span class="line">)  &#125;&#125;</span><br></pre></td></tr></table></figure>
<p><strong>2.3. 目前最终进化版本</strong></p>
<p>这个版本有几个改进如下，供参考:</p>
<p>用let/const取代var。</p>
<p>不用分号(;)作为语句结尾。</p>
<p>Item子组件改用函数定义方式，取代原先的组件定义方式。</p>
<p>能合并的语句都合并。</p>
<p>函数全用箭头函数(注意需额外加装babel-plugin-transform-class-properties)。</p>
<p>App.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">import React, &#123; Component &#125;from&apos;react&apos;</span><br><span class="line">import Item from&apos;./Item2&apos;</span><br><span class="line">export default class App extends Component&#123;</span><br><span class="line">	constructor(props) &#123;</span><br><span class="line">		super(props)</span><br><span class="line">		this.state = &#123;options: [ </span><br><span class="line">		&#123;name:&apos;（1）免费行李&apos;,value:1&#125;,</span><br><span class="line">		&#123;name:&apos;2&apos;,value:2&#125;, </span><br><span class="line">		&#123;name:&apos;3&apos;,value:3&#125;],</span><br><span class="line">  changePrice =(value) =&gt;&#123;</span><br><span class="line">	  let price =800</span><br><span class="line">	  if(value ===1) </span><br><span class="line">		  price =0</span><br><span class="line">	  else</span><br><span class="line">	  price *= value -1</span><br><span class="line">render() &#123;</span><br><span class="line">	return(</span><br><span class="line"></span><br><span class="line">	&lt;div&gt;&#123;this.state.price&#125;&lt;/div&gt;</span><br><span class="line">	</span><br><span class="line">	)  </span><br><span class="line">&#125;&#125;</span><br></pre></td></tr></table></figure>
<p>Item.js</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import React from&apos;react&apos;</span><br><span class="line">const Item =(props) =&gt;&#123;</span><br><span class="line">const optionArray = props.optionArray</span><br><span class="line">const options = optionArray.map((item, index) =&gt;&#123;return(&#123;item.name&#125;)  &#125;)return(</span><br><span class="line"></span><br><span class="line">&#123;props.changePrice(e.target.value)&#125;&#125;&gt;  &#123;options&#125;</span><br><span class="line"></span><br><span class="line">)&#125;</span><br><span class="line">export default Item</span><br></pre></td></tr></table></figure>
<p><br><br><strong>3.参考文档</strong><br><br><br>参考文档: 1. <a href="https://www.cnblogs.com/zhangbob/p/6962138.html?utm_source=itdadao&amp;utm_medium=referral" target="_blank" rel="noopener">https://www.cnblogs.com/zhangbob/p/6962138.html?utm_source=itdadao&amp;utm_medium=referral</a></p>
<ol start="2">
<li><a href="http://www.css88.com/react/docs/lifting-state-up.html官方文档" target="_blank" rel="noopener">http://www.css88.com/react/docs/lifting-state-up.html官方文档</a></li>
</ol>
<p>3.<a href="https://blog.csdn.net/YQXLLWY/article/details/73481063" target="_blank" rel="noopener">https://blog.csdn.net/YQXLLWY/article/details/73481063</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/03/25/记录博客搭建踩过的坑/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/25/记录博客搭建踩过的坑/" itemprop="url">记录博客搭建踩过的坑</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-25T14:47:58+08:00">
                2017-03-25
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/博客搭建/" itemprop="url" rel="index">
                    <span itemprop="name">博客搭建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/25/记录博客搭建踩过的坑/" class="leancloud_visitors" data-flag-title="记录博客搭建踩过的坑">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>本人的博客使用的是hexo+github搭建的一套独立博客, 主题采用的是next,经过两天的折腾, 博客也弄得有模有样了.(微笑).<br>现在记录一下踩过的坑,希望自己可以好好总结, 能帮助到萌新就更好了,哈哈!<br>问题不分顺序,本人比较懒, 想到啥就写啥.</p>
<p><strong>1.解决编辑器的问题</strong><br>  hexo是使用markdown编辑器的,如果不想在本地安装markDown,(我就懒得安装), 那么CSDN了解一下.<br>  在CSDN写文章的编辑器中 , 切换成markDown, 编辑完之后选择导出到本地, 然后将这个文件放置到你的相应文件夹下, 搞定 .</p>
<p><strong>2.给hexo博客添加系列文章功能</strong><br>之前已经讲过, hexo new page categories 便可以新建一个categories页面,<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-03-02 12:33:16</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>实际上调用hexo new page xxx后，会在/source/categories/目录下生成一个index.md文档，在此文档头部加上上面这段即可。实际上，index.md里只需要有这个声明即可，其他内容并不会显示出来，写了也没用。<br>(1)新建文章<br>hexo new ‘文章名’<br>(2)设置分类<br>这一步是重点了, 在上一步中,我们可以看到已经创建了一个 ‘文章名.md’的文件,在source/_posts文件夹下可以找到.<br>大概长这样:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title:  记录博客搭建踩过的坑</span><br><span class="line">date: 2017-03-25 14:47:58</span><br><span class="line">tags:</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p>你只需要在tags标签下添加分类名称就可以了,像这样:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tags:</span><br><span class="line">categories: 博客搭建</span><br></pre></td></tr></table></figure>
<p>PS. 无论是page，还是post的文章，都是以.md格式结尾，在hexo g的过程中会产生对应的.html文档，然后hexo d到Github上的也只是html文档，不是.md格式的文档。<br>另外就是，需要注意一点：如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false，如：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">---</span><br><span class="line">title: categories</span><br><span class="line">date: 2018-03-02 12:33:16</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br><span class="line">---</span><br></pre></td></tr></table></figure></p>
<p><strong>3.HEXO 出现 &gt; -bash: hexo: command not found</strong></p>
<p>在执行hexo deploy的时候一直出现ERROR Deployer not found: git。<br>_config.yml是配置文件,见下图：hexo在2点几的版本中type: github。之后的版本是type: git<br><img src="https://img-blog.csdn.net/20180704164154206?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>解决方法:</p>
<blockquote>
<p>npm install hexo-deployer-git –save<br>hexo d -g</p>
</blockquote>
<p><strong>4.将博客部署到github pages出问题</strong></p>
<p>最常见的就是两个问题, (1)ssh Key的问题, (2) github上setting的问题<br>如何部署就不说了, 这里贴上两篇教程 ,<a href="https://blog.csdn.net/u011974987/article/details/51331822/" target="_blank" rel="noopener">https://blog.csdn.net/u011974987/article/details/51331822/</a><br><a href="https://www.cnblogs.com/imapla/p/5533000.html" target="_blank" rel="noopener">https://www.cnblogs.com/imapla/p/5533000.html</a></p>
<p>(1)ssh Key的问题<br><img src="https://img-blog.csdn.net/20180704153412384?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>照着<a href="https://www.jianshu.com/p/301afa16f471" target="_blank" rel="noopener">这篇教程,</a> 重新生成一个sshKey, 并将公钥放置到你的仓库中.</p>
<p>(2)setting的问题</p>
<p>这里需要说明的是, github需要设置pages的仓库名称, 必须是以io结尾的., 这个命名也是个坑, 格式必须是youname.github.io这种。其次youname必须是你的github的用户名.<br>在仓库的setting的options中,找到GitHub Pages模块,在source中选择分支,并点击保存,再刷新页面就会看到有一个网址, 类似这样:<br><img src="https://img-blog.csdn.net/20180704161327622?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>如果是需要在README.md中查看到博客网址的话,可以在README.md中使用一个a标签,href链接地址就是这个红色框的地址. 如果是其他仓库,则需要加上index.html索引文件 .<br>如果没有出现上面所说的网址,打开链接的错误地址,如果是遇到下面这个问题 :<br><img src="https://img-blog.csdn.net/2018070416323750?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>很明显,是部署失败了, 那么就重新部署吧.<br>部署之前一定要安装这个包</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git –save</span><br></pre></td></tr></table></figure>
<p>然后执行 hexo d -g</p>
<p>5.空格问题<br>需要注意的是,在_config.yml配置文件中,属性名和属性值之间一定要有一个空格<br>不然你会遇到类似下面这种问题:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">错误提示：FATAL bad indentation of a mapping entry at line 72, column 7:</span><br></pre></td></tr></table></figure></p>
<p>或者这种问题</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">错误提示：</span><br><span class="line">You should configure deployment settings in _config.yml first!</span><br><span class="line">Available deployer plugins:</span><br><span class="line">  git</span><br><span class="line">For more help, you can check the online docs: http://hexo.io/</span><br></pre></td></tr></table></figure>
<p>6.404可能原因<br>(1).域名解析错误。</p>
<p>检查： windows下cmd命令符输入ping cheatlys.info（你的域名） 看一下ip地址，在ping一下你github上的，ping liuyongshun.github.io看一下是否一样，并且没有请求超时。</p>
<p>(2).你的域名是通过国内注册商注册的，因没有实名制而无法访问。</p>
<p>(3).浏览器缓存，路由器缓存。可尝试清除浏览器缓存再访问或者换个浏览器访问，或者换个局域网访问。</p>
<p>(4). 你的hexo配置有问题，而导致index页面在主域名的下一级目录。找到index页面，在域名后面添加下一级目录。看是否能访问index页面（此时样式可能是乱的）。直接在.github.io的库（相当于根目录，在_config.yml配置root时直接是/如果这些内容在blog下，root应该是/blog/）下边展开这些内容。<br><img src="https://img-blog.csdn.net/2018070416543571?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<p>7.绑定域名<br>你需要在本地的source下建立CNAME文件(是文件不是文件夹也没有拓展名)，内容就是你买的的域名（例：不要<a href="http://www.cheatlys.info，而是写cheatlys.info前者直接输入cheatlys.info不会连接到你的网站。）" target="_blank" rel="noopener">www.cheatlys.info，而是写cheatlys.info前者直接输入cheatlys.info不会连接到你的网站。）</a></p>
<p>暂时先写到这里啦,后面想起来再写,</p>
<p><strong>补充日常博客管理</strong><br><strong>日常修改</strong><br>在本地对博客进行修改（添加新博文、修改样式等等）后，通过下面的流程进行管理：</p>
<p>依次执行git add .、git commit -m “…”、git push origin hexo指令将改动推送到GitHub（此时当前分支应为hexo）；<br>然后才执行hexo generate -d发布网站到master分支上。<br>虽然两个过程顺序调转一般不会有问题，不过逻辑上这样的顺序是绝对没问题的（例如突然死机要重装了，悲催….的情况，调转顺序就有问题了）。</p>
<p><strong>本地资料丢失</strong><br>当重装电脑之后，或者想在其他电脑上修改博客，可以使用下列步骤：</p>
<p>使用git clone <a href="mailto:git@github.com" target="_blank" rel="noopener">git@github.com</a>:CrazyMilk/CrazyMilk.github.io.git拷贝仓库（默认分支为hexo）；<br>在本地新拷贝的CrazyMilk.github.io文件夹下通过Git bash依次执行下列指令：npm install hexo、npm install、npm install hexo-deployer-git（记得，不需要hexo init这条指令）。</p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/03/23/archives-git知识点/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/23/archives-git知识点/" itemprop="url">使用hexo+github搭建个人博客(进阶篇)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-23T00:00:00+08:00">
                2017-03-23
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/博客搭建/" itemprop="url" rel="index">
                    <span itemprop="name">博客搭建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/23/archives-git知识点/" class="leancloud_visitors" data-flag-title="使用hexo+github搭建个人博客(进阶篇)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p><strong>1. Hexo简介</strong><br>Hexo 是一款基于 Node.js 的静态博客框架。Hexo 使用 Markdown 解析文章，用户在本地安装Hexo并进行写作，通过一条命令，Hexo即可利用靓丽的主题自动生成静态网页。<br>参考：<a href="https://github.com/hexojs/hexo" target="_blank" rel="noopener">Hexo-Github地址</a>        <a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">Hexo帮助文档</a><br><img src="https://img-blog.csdn.net/20180704101848462?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br><strong>2. 博客环境搭建</strong><br><strong>2.1 安装Git</strong><br>Windows平台：以 Win7 64位机为例</p>
<p>到<a href="https://git-scm.com/download" target="_blank" rel="noopener">官网</a>下载 Git，一路默认选项安装。本文使用的是Git-2.8.1-64-bit. </p>
<p>Linux平台</p>
<p>2.2 安装Node.js<br>Windows平台：以 Win7 64位机为例</p>
<p>到官网下载 Node.js，一路默认选项安装。本文使用的是node-v4.4.2-x64，需要的用户可以点此下载 。</p>
<p>Linux平台</p>
<p><strong>2.3 安装Hexo</strong><br>Git 和 Node.js 都安装好后,首先创建一个用于存放博客文件的文件夹，如 blog，然后进入 blog 文件夹，下面开始安装并使用 Hexo。</p>
<p><strong>安装并初始化Hexo</strong></p>
<p>右键选择 git bash here ，弹出Git Bash窗口；执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ npm install -g hexo-cli</span><br><span class="line">$ hexo init</span><br></pre></td></tr></table></figure>
<p>安装完成后，指定文件夹的目录如下：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">├── _config.yml</span><br><span class="line">├── package.json</span><br><span class="line">├── scaffolds</span><br><span class="line">├── source</span><br><span class="line">|   ├── _drafts</span><br><span class="line">|   └── _posts</span><br><span class="line">└── themes</span><br></pre></td></tr></table></figure></p>
<p>其中<strong>_config.yml</strong>文件用于存放网站的配置信息，你可以在此配置大部分的参数；<strong>scaffolds</strong>是存放模板的文件夹，当新建文章时，Hexo会根据<strong>scaffold</strong>来建立文件；<strong>source</strong>是资源文件夹，用于存放用户资源，<strong>themes</strong>是主题文件夹，存放博客主题，Hexo 会根据主题来生成静态页面。</p>
<p><strong>生成静态博客文件</strong></p>
<p>在Git Bash终端执行命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ hexo g</span><br><span class="line">$ hexo s</span><br></pre></td></tr></table></figure>
<p>Hexo将source文件夹中的Markdown 和 HTML 文件会被解析并放到public文件夹中，public文件夹用于存放静态博客文件，相当于网站根目录。<br>至此博客雏形基本完成，在浏览器中访问<a href="http://localhost:4000/，如图所示：" target="_blank" rel="noopener">http://localhost:4000/，如图所示：</a></p>
<p><img src="https://img-blog.csdn.net/20180704100855165?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="002"></p>
<p><strong>2.4 使用nexT主题</strong><br><strong>下载nexT主题</strong></p>
<p>在Git Bash终端执行以下命令：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ git clone https://github.com/iissnan/hexo-theme-next themes/next</span><br></pre></td></tr></table></figure>
<p>解压所下载的压缩包至站点的 themes 目录下， 并将解压后的文件夹名称更改为 next 。本文使用hexo-theme-next-5.0.1 。</p>
<p><strong>启用nexT主题</strong></p>
<p>打开站点配置文件 _config.yml，找到 theme 字段，并将其值更改为 next。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">theme: next</span><br></pre></td></tr></table></figure>
<p>在Git Bash终端执行命令hexo s，在浏览器中访问<a href="http://localhost:4000/，当你看到站点的外观与下图所示类似时即说明你已成功安装" target="_blank" rel="noopener">http://localhost:4000/，当你看到站点的外观与下图所示类似时即说明你已成功安装</a> NexT 主题。这是 NexT 默认的 Scheme —— Muse。</p>
<p><img src="https://img-blog.csdn.net/20180704101136590?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="003"><br>本博客使用的是NexT.Pisces主题，修改主题配置文件 _config.yml的 Schemes 字段的值为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">scheme: Pisces</span><br></pre></td></tr></table></figure>
<p>博客预览如图：</p>
<p><img src="https://img-blog.csdn.net/20180704172200197?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<ol start="3">
<li>NexT主题配置<br>3.1 主题基本设定<br>参照<a href="http://theme-next.iissnan.com/getting-started.html#theme-settings" target="_blank" rel="noopener">NexT使用文档</a>，设置界面语言、菜单、侧栏、头像、作者昵称和站点描述。由于该使用文档描述非常详细，本文不再赘述。此处需要注意，添加新的菜单项时，需要手动创建该页面才能正常访问，下面以分类页面为例讲述创建新页面的方法：</li>
</ol>
<p><strong>创建分类页面</strong></p>
<p>在Git Bash终端执行命令:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ hexo new page categories</span><br></pre></td></tr></table></figure>
<p><strong>编辑分类页面</strong></p>
<p>添加页面类型字段，将其值设置为 “categories”，主题将自动为这个页面显示所有分类，如果有启用多说 或者 Disqus 评论，默认页面也会带有评论。需要关闭的话，请添加字段 comments 并将值设置为 false。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">title: 分类</span><br><span class="line">date: 2014-12-22 12:39:04</span><br><span class="line">type: &quot;categories&quot;</span><br><span class="line">comments: false</span><br></pre></td></tr></table></figure></p>
<p>创建标签页的方法同上，只需要将type字段设置为”tags”即可。</p>
<p><strong>3.2 添加侧栏社交链接和友链</strong></p>
<p><strong>添加侧栏社交链接</strong></p>
<p>在主题配置文件 _config.yml中Sidebar Settings部分添加字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># Social Links</span><br><span class="line">social:</span><br><span class="line">  GitHub: https://github.com/wuxubj</span><br><span class="line">  Weibo: http://weibo.com/wuxubj</span><br></pre></td></tr></table></figure>
<p>本博客将侧栏社交链接设置居中显示，修改themes\next\source\css_common\components\sidebar\sidebar-author-links.styl文件，添加如下样式：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.links-of-author-item &#123;</span><br><span class="line">  text-align: center;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>添加侧栏友情链接</strong></p>
<p>在主题配置文件 _config.yml中Sidebar Settings部分添加字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"># Blogrolls</span><br><span class="line">links_title: 友情链接</span><br><span class="line">links_layout: inline</span><br><span class="line">links_icon: link  # 设置图标</span><br><span class="line">links:</span><br><span class="line">  鱼汐笔记: https://yidongying.github.io/</span><br></pre></td></tr></table></figure>
<p>本博客侧栏友情链接使用了与侧栏社交链接相同的css样式，但文本左对齐。实现方法为：<br>修改themes\next\layout_macro\sidebar.swig，将如下内容</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&lt;ul class=&quot;links-of-blogroll-list&quot;&gt;</span><br><span class="line">  &#123;% for name, link in theme.links %&#125;</span><br><span class="line">    &lt;li class=&quot;links-of-blogroll-item&quot;&gt;</span><br><span class="line">      &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">        &#123;&#123; name &#125;&#125;</span><br><span class="line">      &lt;/a&gt;</span><br><span class="line">    &lt;/li&gt;</span><br><span class="line">  &#123;% endfor %&#125;</span><br><span class="line">&lt;/ul&gt;</span><br></pre></td></tr></table></figure>
<p>修改为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;% for name, link in theme.links %&#125;</span><br><span class="line">  &lt;span class=&quot;links-of-author-item&quot; style=&quot;text-align:left&quot;&gt;</span><br><span class="line">    &lt;a href=&quot;&#123;&#123; link &#125;&#125;&quot; title=&quot;&#123;&#123; name &#125;&#125;&quot; target=&quot;_blank&quot;&gt;</span><br><span class="line">      &#123;&#123; name &#125;&#125;</span><br><span class="line">    &lt;/a&gt;</span><br><span class="line">  &lt;/span&gt;</span><br><span class="line">&#123;% endfor %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>3.3 设置阅读次数统计</strong><br>需要在leanCloud注册一个账号, 前往 <a href="https://leancloud.cn/dashboard" target="_blank" rel="noopener">https://leancloud.cn/dashboard</a> , 注册账号是为了得到一个appId 和appKey, 如下图所示:<br><img src="https://img-blog.csdn.net/20180704103006573?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>具体的操作就不多说了, 请查看 <a href="https://notes.wanghao.work/2015-10-21-%E4%B8%BANexT%E4%B8%BB%E9%A2%98%E6%B7%BB%E5%8A%A0%E6%96%87%E7%AB%A0%E9%98%85%E8%AF%BB%E9%87%8F%E7%BB%9F%E8%AE%A1%E5%8A%9F%E8%83%BD.html#%E9%85%8D%E7%BD%AELeanCloud" target="_blank" rel="noopener">这里的教程</a><br>复制AppID以及AppKey并在NexT主题的_config.yml文件中我们相应的位置填入即可，正确配置之后文件内容像这个样子:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">leancloud_visitors:</span><br><span class="line">  enable: true</span><br><span class="line">  app_id: joaeuuc4hsqudUUwx4gIvGF6-gzGzoHsz</span><br><span class="line">  app_key: E9UJsJpw1omCHuS22PdSpKoh</span><br></pre></td></tr></table></figure>
<p><strong>3.4 添加cnzz站长统计</strong><br><strong>添加站长统计</strong></p>
<p>到<a href="https://err.taobao.com/error1.html?c=404&amp;u=https://www.taobao.com/markets/umplus/www/signup?spm=0.0.0.0.ma5nae&amp;r=http://www.wuxubj.cn/2016/08/Hexo-nexT-build-personal-blog/" target="_blank" rel="noopener">友盟+</a>注册账户，并添加自己的网站域名，获取到一个站点ID，这个ID可以在地址栏里，或者自动生成的脚本里面找到。<br>在主题配置文件 _config.yml中添加如下字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># CNZZ count</span><br><span class="line">cnzz_siteid: 1259784696</span><br></pre></td></tr></table></figure>
<p><strong>注意把字段cnzz_siteid的值修改为你自己的站点ID。</strong><br>修改themes\next\layout_layout.swig文件，添加如下内容，用于生成cnzz统计代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;% include &apos;_scripts/third-party/analytics/cnzz-analytics.swig&apos; %&#125;</span><br></pre></td></tr></table></figure>
<p>至此cnzz站长统计功能已经添加。由于默认默认不显示“站长统计”字样，所以从页面外观看不到任何变化。</p>
<p><strong>页脚添加“站长统计”链接</strong></p>
<p>修改\themes\next\layout_partials\footer.swig文件，在<span class="author" itemprop="copyrightHolder"></span>后面添加如下代码：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.cnzz_siteid %&#125;</span><br><span class="line">   &lt;span style=&quot;margin-left:8px;&quot;&gt;</span><br><span class="line">   &lt;script src=&quot;http://s6.cnzz.com/stat.php?id=&#123;&#123; theme.cnzz_siteid &#125;&#125;&amp;web_id=&#123;&#123; theme.cnzz_siteid &#125;&#125;&quot; type=&quot;text/javascript&quot;&gt;&lt;/script&gt;</span><br><span class="line">   &lt;/span&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>4.网站发布</strong><br><strong>4.1 云主机</strong><br>学生党推荐参加腾讯云云+校园优惠活动，云主机+CN域名只需1元/月。<br>工作党建议花钱购买云主机，个人博客选择最便宜的就行，一年几百元人民币。<br><strong>4.2 Git托管的Pages服务</strong><br>常用的有GitHub pages和Coding Pages。<br>GitHub pages 的使用教程参见：GitHub Pages + Hexo搭建博客 Hexo 3.1.1 静态博客搭建指南<br>Coding Pages 的使用教程参见：将hexo博客同时托管到github和coding</p>
<p>我刚开始建站的时候使用的是GitHub pages，后来也部署到了Coding，但访问速度都不咋令人满意。最后我选择了腾讯云主机，顿时感觉访问速度飞快。</p>
<p><strong>5 NexT主题美化</strong></p>
<p><strong>5.1 修改导航栏图标</strong><br>NexT 使用的是 <a href="https://fontawesome.com/?from=io" target="_blank" rel="noopener">Font Awesome</a> 提供的图标， <a href="https://fontawesome.com/?from=io" target="_blank" rel="noopener">Font Awesome</a> 提供了 600+ 的图标，可以满足绝大的多数的场景，同时无须担心在 Retina 屏幕下 图标模糊的问题。对应的文件在themes\next\source\vendors\font-awesome中。<br>在<a href="http://fontawesome.dashgame.com/中有图标与其名称的对应，用户可根据需要修改图标。我的menu_icons配置为：" target="_blank" rel="noopener">http://fontawesome.dashgame.com/中有图标与其名称的对应，用户可根据需要修改图标。我的menu_icons配置为：</a></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">menu_icons:</span><br><span class="line">  enable: true</span><br><span class="line">  #KeyMapsToMenuItemKey: NameOfTheIconFromFontAwesome</span><br><span class="line">  home: home</span><br><span class="line">  about: user</span><br><span class="line">  categories: th</span><br><span class="line">  tags: tags</span><br><span class="line">  archives: calendar-check-o</span><br></pre></td></tr></table></figure>
<p><strong>5.2 修改文章内链接文本样式</strong><br>将链接文本设置为蓝色，鼠标划过时文字颜色加深，并显示下划线。<br>修改文件themes\next\source\css_common\components\post\post.styl，添加如下css样式：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">.post-body p a&#123;</span><br><span class="line">  color: #0593d3;</span><br><span class="line">  border-bottom: none;</span><br><span class="line">  &amp;:hover &#123;</span><br><span class="line">    color: #0477ab;</span><br><span class="line">    text-decoration: underline;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>选择.post-body是为了不影响标题，选择p是为了不影响首页“阅读全文”的显示样式。</p>
<p><strong>5.3 文章末尾添加本文结束标记</strong></p>
<p><strong>新建 passage-end-tag.swig 文件</strong><br>在路径\themes\next\layout_macro中添加passage-end-tag.swig文件，其内容为：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;% if theme.passage_end_tag.enabled %&#125;</span><br><span class="line">&lt;div style=&quot;text-align:center;color: #ccc;font-size:14px;&quot;&gt;</span><br><span class="line">------ 本文结束 ------&lt;/div&gt;</span><br><span class="line">&#123;% endif %&#125;</span><br></pre></td></tr></table></figure>
<p><strong>修改 post.swig 文件</strong><br>在\themes\next\layout_macro\post.swig中，post-body之后，post-footer之前添加如下代码：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&lt;div&gt;</span><br><span class="line">  &#123;% if not is_index %&#125;</span><br><span class="line">    &#123;% include &apos;passage-end-tag.swig&apos; %&#125;</span><br><span class="line">  &#123;% endif %&#125;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p><strong>在主题配置文件中添加字段</strong></p>
<p>在主题配置文件 _config.yml中添加以下字段开启此功能：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"># 文章末尾添加“本文结束”标记</span><br><span class="line">passage_end_tag:</span><br><span class="line">  enabled: true</span><br></pre></td></tr></table></figure>
<p>完成以上设置之后，在每篇文章之后都会添加“本文结束”标记。<br>该功能简易添加方法参见：<a href="https://github.com/iissnan/hexo-theme-next/issues/1039" target="_blank" rel="noopener">Issues of hexo-theme-next</a><br><strong>5.4 文章末尾添加网站二维码</strong><br><strong>利用 NexT 主题自带的wechat_subscriber功能在文章末尾添加网站二维码。</strong><br>首先生成你网站的二维码，放到网站根目录下的images文件夹中，然后修改主题配置文件 _config.yml，添加如下内容：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"># Wechat Subscriber</span><br><span class="line">wechat_subscriber:</span><br><span class="line">  enabled: true</span><br><span class="line">  qcode: /images/wuxubj.png</span><br><span class="line">  description: 扫一扫，用手机访问本站</span><br></pre></td></tr></table></figure></p>
<p><strong>5.5 其他美化</strong><br>1.标签云页面鼠标划过字体加粗<br>2.文章末尾标签鼠标划过变蓝色<br>3.调换文章末尾上一篇和下一篇链接显示位置（左右互换）<br>4.优化文章末尾上一篇和下一篇链接显示效果完成以上设置之后，在每篇文章之后都会添加网站二维码。</p>
<p><strong>6.SEO推广</strong><br><strong>6.1 生成sitemap</strong><br>Sitemap用于通知搜索引擎网站上有哪些可供抓取的网页，以便搜索引擎可以更加智能地抓取网站。<br>执行以下命令，安装插件hexo-generator-sitemap，用于生成sitemap：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install hexo-generator-sitemap --save</span><br></pre></td></tr></table></figure>
<p>在站点配置文件 _config.yml中添加如下字段：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sitemap:</span><br><span class="line">path: sitemap.xml</span><br></pre></td></tr></table></figure>
<p>执行hexo g，就会在网站根目录生成 sitemap.xml 。</p>
<p><strong>6.2 开启百度自动推送</strong><br>在主题配置文件 _config.yml中添加如下字段：<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">baidu_push: true</span><br></pre></td></tr></table></figure></p>
<p><strong>6.3 使用各大搜索引擎站长工具</strong><br>    在搜索引擎搜索框输入site:your.domain可以查看域名是否被该搜索引擎收录，用户可以使用各大搜索引擎站长工具提交个人博客网址。</p>
<p><strong>7.更换配置</strong><br>    这里记录一个我遇到的麻烦, 更换电脑之后,重新更新博客,遇到了一系列的问题,我的博客是备份在了github上面,当我拉下代码发现_.config.html文件不存在, 而使用hexo的都知道,hexo主要是需要配置文件, 幸好原来的电脑还保存着一份配置文件, 于是新建了一个文件夹, 然后hexo init  , hexo g ,hexo s,打开localhost:4000就可以看到生成了一个博客, 这时,替换配置文件, 并把拉下来的代码放置到source文件夹中 .之后又出现了git的问题, 很明显, ssh key肯定是不对的, 那么就需要进行设置了, 这个可以参考我的<a href="https://www.jianshu.com/p/301afa16f471" target="_blank" rel="noopener">这篇文章</a><br>    这里提醒一下各位,如果是刚开始建博客, 最好设置两个分支,dev/master用来放置静态网站页面文件,hexo分支用来放置配置文件.具体可以参考<a href="https://blog.csdn.net/Rainy_X/article/details/79829181" target="_blank" rel="noopener">网上的资源</a></p>
<p><strong>8.相关资源</strong><br><a href="https://github.com/yidongying/yidongying.github.io" target="_blank" rel="noopener">我的站点文件备份</a><br><a href="https://github.com/wuxubj/hexo-theme-next-wuxubj/releases" target="_blank" rel="noopener">优化之后的NexT主题下载</a><br><a href="http://markdownpad.com/" target="_blank" rel="noopener">markdownpad2</a><br><a href="https://notepad-plus-plus.org/download/v6.9.2.html" target="_blank" rel="noopener">Notepad++ v6.9.2</a><br><a href="https://git-scm.com/" target="_blank" rel="noopener">Git-2.8.1-64-bit</a><br><a href="https://nodejs.org/zh-cn/" target="_blank" rel="noopener">node-v4.4.2-x64</a></p>
<p><strong>9.参考文档</strong><br>(1)<a href="https://hexo.io/zh-cn/docs/" target="_blank" rel="noopener">hexo官方文档</a><br>(2) <a href="http://theme-next.iissnan.com/" target="_blank" rel="noopener">next主题官方文档</a><br>(3) <a href="http://theme-next.iissnan.com/third-party-services.html#algolia-search" target="_blank" rel="noopener">第三方服务集成</a><br>(4)<a href="https://github.com/iissnan/hexo-theme-next/wiki/%E4%B8%BB%E9%A2%98%E9%85%8D%E7%BD%AE%E5%8F%82%E8%80%83" target="_blank" rel="noopener">next主题特性配置</a><br>(5)<a href="https://blog.csdn.net/wxl1555/article/details/79293159" target="_blank" rel="noopener">电脑更换后的问题</a></p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="https://yidongying.github.io/2017/03/22/hello-world/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="大鱼吃小鱼@">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.png">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="易冬英的博客">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/03/22/hello-world/" itemprop="url">使用hexo+github搭建个人博客(基础篇)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-03-22T00:00:00+08:00">
                2017-03-22
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">分类于</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/博客搭建/" itemprop="url" rel="index">
                    <span itemprop="name">博客搭建</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
          

          
          
             <span id="/2017/03/22/hello-world/" class="leancloud_visitors" data-flag-title="使用hexo+github搭建个人博客(基础篇)">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">阅读次数&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="开始"><a href="#开始" class="headerlink" title="开始"></a>开始</h2><p>本文为建站初期小结，查看完整建站教程：<a href="https://yidongying.github.io/2017/03/23/archives-git%E7%9F%A5%E8%AF%86%E7%82%B9/">Hexo+nexT主题搭建个人博客</a></p>
<p>讲述Hexo的安装，nexT主题的下载及其简单配置。</p>
<h3 id="安装HEXO"><a href="#安装HEXO" class="headerlink" title="安装HEXO"></a>安装HEXO</h3><p>切换到博客所在目录，运行Git Bash，依次执行以下命令：</p>
<p>$ npm install -g hexo-cli<br>$ hexo init<br>$ npm install</p>
<h3 id="指定博客文件夹的目录如下："><a href="#指定博客文件夹的目录如下：" class="headerlink" title="指定博客文件夹的目录如下："></a>指定博客文件夹的目录如下：</h3><p>├── _config.yml<br>├── package.json<br>├── scaffolds<br>├── source<br>|   ├── _drafts<br>|   └── _posts<br>└── themes</p>
<h3 id="运行："><a href="#运行：" class="headerlink" title="运行："></a>运行：</h3><p>$ hexo g<br>$ hexo s</p>
<p>在浏览器中输入：<a href="http://localhost:4000/" target="_blank" rel="noopener">http://localhost:4000/</a>  即可访问本地博客，如下图所示：<br><img src="https://img-blog.csdn.net/20180704171716402?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"><br>参考: <a href="https://hexo.io/zh-cn/docs/troubleshooting.html" target="_blank" rel="noopener">HEXO官方帮助文档</a></p>
<h3 id="下载NexT主题"><a href="#下载NexT主题" class="headerlink" title="下载NexT主题"></a>下载NexT主题</h3><p>切换到博客所在目录，运行Git Bash，执行以下命令：</p>
<p>$  git clone <a href="https://github.com/iissnan/hexo-theme-next" target="_blank" rel="noopener">https://github.com/iissnan/hexo-theme-next</a> themes/next<br>打开站点配置文件_config.yml，将其中的theme: landscape改为theme: next，保存修改，执行hexo g,hexo s,在浏览器中查看本地博客如图：</p>
<p><img src="https://img-blog.csdn.net/20180704171845186?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzM3MjEwNTIz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70" alt="这里写图片描述"></p>
<h3 id="NexT主题简单配置"><a href="#NexT主题简单配置" class="headerlink" title="NexT主题简单配置"></a>NexT主题简单配置</h3><p>根据NexT官方帮助文档，选择scheme为Mist，界面语言为zh-Hans，选择侧栏位置为right，侧栏显示时机为post,添加站点图像，作者昵称，站点描述等基本信息，效果如图：</p>
<h3 id="完成"><a href="#完成" class="headerlink" title="完成"></a>完成</h3><p>至此，个人博客雏形基本显现，下一步进行优化。</p>

          
        
      
    </div>
    
    
    

    

    

    

  <div>
      
  </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  


          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/avatar.png"
                alt="大鱼吃小鱼@" />
            
              <p class="site-author-name" itemprop="name">大鱼吃小鱼@</p>
              <p class="site-description motion-element" itemprop="description">记录IT,记录成长,愿在输得起的年纪,创造更多的奇迹</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/">
              
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">日志</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">3</span>
                  <span class="site-state-item-name">分类</span>
                
              </div>
            

            

          </nav>

          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/yidongying" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/yi-dong-ying-72/activities" target="_blank" title="Zhihu">
                      
                        <i class="fa fa-fw fa-globe"></i>Zhihu</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://weibo.com/5222949342/profile?rightmod=1&wvr=6&mod=personinfo" target="_blank" title="Weibo">
                      
                        <i class="fa fa-fw fa-globe"></i>Weibo</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://juejin.im/user/59a532a6f265da248b04ebda" target="_blank" title="juejin">
                      
                        <i class="fa fa-fw fa-globe"></i>juejin</a>
                  </span>
                
            </div>
          

          
          

          
          
            <div class="links-of-blogroll motion-element links-of-blogroll-inline">
              <div class="links-of-blogroll-title">
                <i class="fa  fa-fw fa-link"></i>
                友情连接
              </div>
              <ul class="links-of-blogroll-list">
               
                <span class="links-of-author-item" style="text-align:left">
                  <a href="https://github.com/yidongying/web_front_source" title="学习资源收集" target="_blank">
                    学习资源收集
                  </a>
                </span>
              
                <span class="links-of-author-item" style="text-align:left">
                  <a href="https://www.colabug.com/2303894.html" title="开发指南指引" target="_blank">
                    开发指南指引
                  </a>
                </span>
              
                <span class="links-of-author-item" style="text-align:left">
                  <a href="http://localhost:4000/2017/03/22/hello-world/" title="博客搭建指导" target="_blank">
                    博客搭建指导
                  </a>
                </span>
              
              </ul>
            </div>
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; 2017 &mdash; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">大鱼吃小鱼@</span>

  
</div>


  <div class="powered-by">由 <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a> 强力驱动</div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">主题 &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Pisces</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("inY1AtIRYvoTTvLxcFHkLbd4-gzGzoHsz", "KY2YVwAqi9L9bNB8RU2kLRx6");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  
<script>
(function(){
    var bp = document.createElement('script');
    var curProtocol = window.location.protocol.split(':')[0];
    if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';        
    }
    else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
    }
    var s = document.getElementsByTagName("script")[0];
    s.parentNode.insertBefore(bp, s);
})();
</script>


  
  

  

  

  

</body>
</html>
